# 代码随想录算法训练营第4天 24. 两两交换链表中的节点，19.删除链表的倒数第N个节点，面试题 02.07. 链表相交，142.环形链表II，链表总结篇

# 一、刷题部分

## 1.1 24. 两两交换链表中的节点

- 原文链接：[代码随想录](https://programmercarl.com/0024.两两交换链表中的节点.html#_24-两两交换链表中的节点)
- 题目链接：[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

### 1.1.1 题目描述

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

### 1.1.2 初见想法

这其实是上一题的更复杂版本，每一次更改需要涉及交换的 2 个节点以及前后 2 个节点共 4 个节点的操作。如果有了上一题的扎实基础的话，这题写起来应该非常轻松的。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        //考虑节点个数为0或1的情况
        if (head == nullptr) {
            return head;
        }
        if (head -> next == nullptr) {
            return head;
        }
        ListNode* pre = nullptr;
        ListNode* cur1 = head;
        ListNode* cur2 = head -> next;
        ListNode* nxt = nullptr;
        head = cur2;
        
        //开始交换
        while (true) {
            nxt = cur2 -> next;

            //考虑一开始pre节点是nullptr的情况
            if (pre != nullptr) {
                pre -> next = cur2;
            }
            cur2 -> next = cur1;
            cur1 -> next = nxt;

            //若本次是最后一次
            if (nxt == nullptr || nxt -> next == nullptr) {
                break;
            }

            //确定不是最后一遍循环可以放心地节点指针整体后移2位
            pre = cur1;
            cur1 = nxt;
            cur2 = nxt -> next;
        }

        return head;
    }
};
```

也确实如我所料，写起来流畅并且运行通过。接下来看看录里有没有新东西。

### 1.1.3 看录后想法

感觉录里的写法总是比我简洁呢，虽然思路都是差不多的。把 pre 和 nxt 作为两个临时指针，只关心 cur1 和 cur2的操作，剩下的两个指针每次更新就行。

### 1.1.4 遇到的困难

🈚️

## 1.2 19.删除链表的倒数第N个节点

- 原文链接：[代码随想录](https://programmercarl.com/0019.删除链表的倒数第N个节点.html#_19-删除链表的倒数第n个节点)
- 题目链接：[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

### 1.2.1 题目描述

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天-1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

**进阶：**你能尝试使用一趟扫描实现吗？

### 1.2.2 初见想法

一般说来这种需要扫描到末尾才能确定末尾是谁从而向前推 n 个元素。

弄一个指针数组把链表全记下来也实在有点无聊了。

又看到题目想要 1 趟遍历，那么应该可以想到双指针法。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(-1, head);
        //fastIndex 向前探索直到最后nullptr
        ListNode* fastIndex = dummyHead;
        //slowIndex 指向待删节点的前驱节点
        ListNode* slowIndex = dummyHead;

        //先让两指针拉开 n+1 的距离
        for(int i = 0; i <= n; i++) {
            fastIndex = fastIndex -> next;
        }
        while(fastIndex != nullptr) {
            fastIndex = fastIndex -> next;
            slowIndex = slowIndex -> next;
        }

        //删除操作
        ListNode* tmp = slowIndex -> next;
        slowIndex -> next = tmp -> next;
        delete tmp;

        //收尾工作
        head = dummyHead -> next;
        delete dummyHead;
        return head;
    }
};
```

### 1.2.3 看录后想法

和我想的一样。

### 1.2.4 遇到的困难

🈚️

## 1.3 面试题 02.07. 链表相交

- 原文链接：[代码随想录](https://programmercarl.com/面试题02.07.链表相交.html#面试题-02-07-链表相交)
- 题目链接：[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)

### 1.3.1 题目描述

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

 

**示例 1：**

[![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天-1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

[![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天-2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天-3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `0 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`

**进阶：**你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？

### 1.3.2 初见想法

首先找两个指针往后遍历是绝无可能直接知道在哪相交的，一定需要其他的方法来获得其他信息。

看到时间复杂度为 n ，那么干脆把两个链表都遍历一遍求长度，这样就知道应该在哪个位置相交了。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //首先考虑空链表的情况
        if (headA == nullptr || headB == nullptr) {
            return nullptr;
        }
        int lenA = 0, lenB = 0;
        ListNode* curA = nullptr;
        ListNode* curB = nullptr;
        ListNode* intersection = nullptr;
        
        //求A的长度
        curA = headA;
        while (curA != nullptr) {
            lenA++;
            curA = curA -> next;
        }
        //求B的长度
        curB = headB;
        while (curB != nullptr) {
            lenB++;
            curB = curB -> next;
        }

        //先将两个指针的差值抹平
        curA = headA;
        curB = headB;
        if (lenA > lenB) {
            for (int i = 0; i < lenA - lenB; i++) {
                curA = curA -> next;
            }
        } else if (lenA < lenB) {
            for (int i = 0; i < lenB - lenA; i++) {
                curB = curB -> next;
            }
        }

        //共同移动指针，边移动边判断是否相交
        while(curA != nullptr && curB != nullptr) {
            if (curA == curB) {
                intersection = curA;
                break;
            }
            curA = curA -> next;
            curB = curB -> next;
        }

        return intersection;
    }
};
```

### 1.3.3 看录后想法

与我的代码基本一致，录的代码用了 B 比 A 长则交换的方法，我觉得这样不好，因为这样相当于改变了传入参数原来的属性，我认为这样做是非常危险的。还是我的写法更好一些。

### 1.3.4 遇到的困难

🈚️

## 1.4 142.环形链表II

- 原文链接：[代码随想录](https://programmercarl.com/0142.环形链表II.html#_142-环形链表ii)
- 题目链接：[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

### 1.4.1 题目描述

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天-4.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天-5.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](assets/代码随想录算法训练营第4天/代码随想录算法训练营第4天-6.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。 
```

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

**进阶：**你是否可以使用 `O(1)` 空间解决此题？

### 1.4.2 初见想法

一步一步往下推导。代码的注释写清楚了我的思路了：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        //考虑空链表的情况
        if (head == nullptr) {
            return nullptr;
        }

        //使用2个指针，fast 和 slow，fast每次移动2位，slow每次移动1位
        ListNode *fast = head -> next;
        ListNode *slow = head;
        //二者不断移动，若无环则一定会走到nullptr；否则二者一定会相等
        while (true) {
            //无环退出的条件
            if (fast == nullptr || fast -> next == nullptr) {
                return nullptr;
            }
            //有环退出的条件
            if (slow == fast) {
                break;
            }

            //移动操作，防止fast是最后的一个元素，加入额外判断逻辑
            fast = fast -> next -> next;
            slow = slow -> next;
        }

        //到这里说明一定有环，接下来判断是从哪里进入环的
        //先确定环的大小
        int lenCircle = 0;
        do{
            lenCircle++;
            fast = fast -> next;
        }while(fast != slow);
        //重新定位快慢指针
        slow = fast = head;
        while(lenCircle != 0) {
            fast = fast -> next;
            lenCircle--;
        }
        //往后第一次相遇节点就是入环点
        while(slow != fast) {
            slow = slow -> next;
            fast = fast -> next;
        }

        return slow;
    }
};
```

### 1.4.3 看录后想法

怎么说呢，录里对于找入环点进行了更为详尽的分析，从而发现了将slow移动到head之后再逐个移动下一次相遇点就是入环点这样的规律。我认为我们的方法都挺好的，录里的方法需要多分析一下，而我的代码在执行效率基本不变的情况下减少了一些思考难度。

### 1.4.4 遇到的困难

本题有点思考性的，不过写下来还算顺利，成就感满满，感觉到自己水平的提升了。

## 1.5 链表总结篇

- 原文链接：[代码随想录](https://programmercarl.com/链表总结篇.html#链表总结篇)
- 题目链接：🈚️

一趟下来学到的一个是虚拟头节点原来是可以觉得方便就自己直接加上去的，然后对链表的各种操作又进行了一遍训练，最后几道技巧性大一点的题目也是顺利做出来了，收货了成就感。

# 二、总结与回顾

感觉自己的代码能力有了一定的提高，挺开心。

学习时长：3h