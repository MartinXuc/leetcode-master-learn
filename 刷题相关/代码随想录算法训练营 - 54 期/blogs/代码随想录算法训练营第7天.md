# 代码随想录算法训练营第7天 第454题.四数相加II，383. 赎金信，第15题. 三数之和，第18题. 四数之和，哈希表总结篇

# 一、刷题部分

## 1.1 第454题.四数相加II

- 原文链接：[代码随想录](https://programmercarl.com/0454.四数相加II.html#第454题-四数相加ii)
- 题目链接：[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/)

### 1.1.1 题目描述

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**示例 2：**

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

 **提示：**

- `n == nums1.length`
- `n == nums2.length`
- `n == nums3.length`
- `n == nums4.length`
- `1 <= n <= 200`
- `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`

### 1.1.2 初见想法

我能立即想到的就是把这四个数组分成两组，组内使用 $O(n^2)$ 的方法求出和，然后组间使用两数相加的思路，整体是 $O(n^2)$ 的复杂度。

说干就干：

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        int count = 0;
        unordered_map<int,vector<int>> myMap;
        for (int i = 0; i < nums1.size(); i++) {
            for (int j = 0; j < nums2.size(); j++) {
                myMap.insert({nums1[i] + nums2[j], {i, j}});
            }
        }
        for (int i = 0; i < nums3.size(); i++) {
            for (int j = 0; j < nums4.size(); j++) {
                int sum = nums3[i] + nums4[j];
                if (myMap.find(-sum) != myMap.end()) {
                    count++;
                    cout<< myMap[-sum][0] << myMap[-sum][1] << i << j <<endl;
                }
            }
        }
        return count;
    }
};
```

发现这一版是有问题的，因为这个map里的键是有可能重复的。我们需要求的是有多少种可能的结果。

故而使用 multimap 。然而 multimap 的语法我实在不会写，看看题解吧。

### 1.1.3 看录后想法

本题其实不需要去求到底是哪些四元组，而是把四元组的个数求出来就行。因此只需要用一个 unordered_map 即可，key 还是存二者相加结果，value 存出现过的次数。

有了这个点拨立即写出代码：

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        int count = 0;
        unordered_map<int,int> myMap;
        //先将第一组数的信息存到map里
        for (int i = 0; i < nums1.size(); i++) {
            for (int j = 0; j < nums2.size(); j++) {
                int sum = nums1[i] + nums2[j];
                if(myMap.find(sum) != myMap.end()) {
                    myMap[sum]++;
                }
                else {
                    myMap.insert({sum, 1});
                }
            }
        }
        //之后遍历第二组数，找出来符合条件的个数
        for (int i = 0; i < nums3.size(); i++) {
            for (int j = 0; j < nums4.size(); j++) {
                int sum = nums3[i] + nums4[j];
                if (myMap.find(-sum) != myMap.end()) {
                    count += myMap[-sum];
                }
            }
        }
        return count;
    }
};
```

接下来详细看看录里怎么说。

看完录发现想法和我一样，但是使用了一些stl 的语法就简单了很多。我也模仿着写一遍：

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        int count = 0;
        unordered_map<int,int> myMap;
        //先将第一组数的信息存到map里
        for (int num1 : nums1) {
            for (int num2 : nums2) {
                myMap[num1 + num2]++;
            }
        }
        //之后遍历第二组数，找出来符合条件的个数
        for (int num3 : nums3) {
            for (int num4 : nums4) {
                count += myMap[-num3 - num4];
            }
        }
        return count;
    }
};
```

### 1.1.4 遇到的困难

自己的思路还是有一半对的，但是缺忽略了题目想让我求的东西并没有那么复杂，想多了然后又不会就卡住了。不过归根到底还是C++的STL掌握的不好，需要抓紧时间把这一块补上来。

## 1.2 383. 赎金信

- 原文链接：[代码随想录](https://programmercarl.com/0383.赎金信.html#_383-赎金信)
- 题目链接：[383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/description/)

### 1.2.1 题目描述

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 1：**

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

**示例 2：**

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```

**示例 3：**

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

**提示：**

- `1 <= ransomNote.length, magazine.length <= 105`
- `ransomNote` 和 `magazine` 由小写英文字母组成

### 1.2.2 初见想法

与前面的一道题目很像，思路差不太多，还是用一个 unordered_set 写一下就行。

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        //统计magazine里各字母出现次数
        vector<int> letterCount(26, 0);
        for(char c : magazine) {
            letterCount[c - 'a']++;
        }
        //遍历ransomNote，看字母个数够不够组成
        for(char c : ransomNote) {
            letterCount[c - 'a']--;
            if (letterCount[c - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
};
```

### 1.2.3 看录后想法

思路一致，不多说了。

### 1.2.4 遇到的困难

🈚️

## 1.3 第15题. 三数之和

- 原文链接：[代码随想录](https://programmercarl.com/0015.三数之和.html#第15题-三数之和)
- 题目链接：[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

### 1.3.1 题目描述

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

### 1.3.2 初见想法

可以将三数之和分成 两数之和 与 一个数 的和。这样复杂度就可以控制在 n^2。然后下一步还要想怎么样才可以去重。不过还是感觉思路不是很清楚，我想看看题解了。

### 1.3.3 看录后想法

首先把本节主题——哈希表法给过了一遍，然后根据理解自己写了一遍：

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;

        //先将数组排序
        sort(nums.begin(), nums.end());

        //i 指向第一个数字
        for (int i = 0; i < nums.size() - 2; i++) {
            //若第一个数都大于0了，说明和一定找不到
            if (nums[i] > 0) {
                break;
            }
            //若 i 是重复的元素，那么找到的三元组一定是重复的
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            //无序集合存储第二个数
            unordered_set<int> mySet;
            for (int j = i + 1; j < nums.size(); j++) {
                //如果出现连续几个相同的数字且都符合要求，则要去重
                if (j >= i + 3 && nums[j] == nums[j - 1] && nums[j - 1] == nums[j - 2]) {
                    continue;
                }

                int target = 0 - (nums[i] + nums[j]);
                if (mySet.find(target) != mySet.end()) {
                    //如果集合里有目标值，说明j指向的元素可以当做第三个数
                    result.push_back({nums[i], target, nums[j]});
                    //为了去重将该目标值删去
                    mySet.erase(target);
                }
                else {
                    //如果集合里没有目标值，那么将现在j指向的元素当做第二给数存进集合
                    mySet.insert(nums[j]);
                }
            }
        }

        return result;
    }
};
```

发现这个方法确实如同录里所说，实在是有些麻烦。这个去重的思路看起来代码不多，但实际上如果没有题解的提示我想我很难想出来。几个条件一起可以完成去重操作也不是很直观。此外，即使核心的哈希也不是那么好想的，确定第一个数之后，第二个指针又是指向第二个数又是指向第三个数的，第一遍看的时候确实理解不了。

接下来研究一下录里提供的双指针法，思路大概理清了，就是先确定第一个数，然后用 left 和 right 指针分别指向第一个数后面序列的头尾。然后由于是排序过的，那么计算三数之和大了，就右指针左移，小了就左指针右移。这里也需要注意去重的操作，不过这个去重就比前面哈希表法的直观许多。对于第一个数，还是沿用以前的去重方式，如果发现该数与前面一个数相同，说明该找的结果都找完了，直接continue；对于第二个数（left），找到结果之后就向右找第一个与之不同的数；对于第三个数（right），找到结果之后就向左找第一个与之不同的数。然后循环条件保持 left < right 即可。

代码如下：

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < nums.size() - 2; i++) {
            //发现第一个数大于0直接退出
            if (nums[i] > 0) break;
            //对第一个数去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            //找第二个数 和 第三个数
            while (left < right) {
                if ((nums[i] + nums[left] + nums[right]) > 0) {
                    //大了，右边向左移
                    right--;
                }
                else if ((nums[i] + nums[left] + nums[right]) < 0) {
                    //小了，左边向右移
                    left++;
                }
                else {
                    //找到符合的解
                    result.push_back({nums[i], nums[left], nums[right]});
                    // cout << "此时i = " << i << endl;
                    // cout << "此时left = " << left << endl;
                    // cout << "此时right = " << right << endl;
                    left++;
                    right--;
                    //第二个数去重
                    while (left < right && nums[left] == nums[left - 1]) {
                        left++;
                    }
                    //第三个数去重
                    while (left < right && nums[right] == nums[right + 1]) {
                        right--;
                    }
                }
            }
        }

        return result;
    }
}
```

### 1.3.4 遇到的困难

- 哈希的思路一下子想不到
- 对于去重一下子想不到
- 明天再写一遍加深印象，我会写就是我自己的知识😋

## 1.4 第18题. 四数之和

- 原文链接：[代码随想录](https://programmercarl.com/0018.四数之和.html#第18题-四数之和)
- 题目链接：[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)

### 1.4.1 题目描述

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

**提示：**

- `1 <= nums.length <= 200`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`

### 1.4.2 初见想法

可以沿用上一题三数之和的思路，只是第一个数变成两个数的和了，也就是需要 2 层 for 循环。写一下：

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        if (nums.size() < 4) {
            return result;
        }

        sort(nums.begin(), nums.end());

        //四个数分别对应 a,b,c,d
        //a用i来指向
        for (int i = 0; i < nums.size() - 3; i++) {
            //对a去重
            if (i > 0 && nums[i - 1] == nums[i]) {
                continue;
            }
            //第b用j来指向
            for (int j = i + 1; j < nums.size() - 2; j++) {
                //对b去重
                if (j > i + 1 && nums[j - 1] == nums[j]) {
                    continue;
                }

                int left = j + 1;
                int right = nums.size() - 1;

                //开始查找
                while (left < right) {
                    double sum = 0;
                    sum += nums[i];
                    sum += nums[j];
                    sum += nums[left];
                    sum += nums[right];
                    if (sum > target) {
                        right--;
                    }
                    else if (sum < target) {
                        left++;
                    }
                    else {
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});
                        cout << i << " " << j << " " << left << " " << right << endl;
                        //固定移动一位
                        left++;right--;
                        //cd去重
                        while (left < right && nums[left - 1] == nums[left]) {
                            left++;
                        }
                        while (left < right && nums[right + 1] == nums[right]) {
                            right--;
                        }
                    }
                }
            }
        }

        return result;
    }
};
```

调试的时候发现四数相加可能会超出 int 的范围，我直接用double类型来存也通过了，看看题解对这个问题怎么处理的。

### 1.4.3 看录后想法

录里提供了一种剪枝的思路，可以参考学习一下： `if(nums[i] > target && (nums[i]) > 0 && target > 0)`。我直接没有剪枝，录的方法应该可以节省一点时间。

### 1.4.4 遇到的困难

沿用三数之和的代码，发现第一层剪枝用不了，发现这个错误之后直接不用剪枝即可。

对于 sum 溢出问题，录使用了 long 来存储，也是一种方法。

## 1.5 哈希表总结篇

- 原文链接：[代码随想录](https://programmercarl.com/哈希表总结.html#哈希表总结篇)

哈希表最主要的用途就是判断一个元素是否出现过。C++ 可以使用数组、集合、map 来作为容器来装数据。数组适用于元素个数已知且有限的情况，如 26 个英文字母，集合是对数组无法处理无限元素的情况的补充，而 map 主要可以用来处理键值对。

本节对 multimap 没有讲解，如何使用我也不清楚，这个就标记一下留住，以后如果用的到的话再去补充学习。

# 二、总结与回顾

对哈希表的用法有了更为深刻的了解了，同时也对双指针加深了印象。期待后续对双指针的大总结。
