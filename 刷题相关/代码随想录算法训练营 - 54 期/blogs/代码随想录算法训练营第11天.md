# 代码随想录算法训练营第11天 | 150. 逆波兰表达式求值，239. 滑动窗口最大值，347.前 K 个高频元素

# 一、刷题部分

## 1.1 150. 逆波兰表达式求值

- 原文链接：[代码随想录](https://programmercarl.com/0150.逆波兰表达式求值.html#_150-逆波兰表达式求值)
- 题目链接：[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

### 1.1.1 题目描述

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

-   有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
-   每个操作数（运算对象）都可以是一个整数或者另一个表达式。
-   两个整数之间的除法总是 **向零截断** 。
-   表达式中不含除零运算。
-   输入是一个根据逆波兰表示法表示的算术表达式。
-   答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

**提示：**

-   `1 <= tokens.length <= 104`
-   `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

-   平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
-   该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

-   去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + * `也可以依据次序计算出正确结果。
-   适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

### 1.1.2 初见思路

任务大纲建议先看视频再做题，那我也就听话了，不多耽误时间。

### 1.1.3 正式做题

题目给出了后缀表达式，那么就用栈来计算：

-   如果遍历到数字，则入栈

-   如果遍历到运算符，则取栈顶两元素，按运算符求结果后入栈

写出代码：

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        for (string token : tokens) {
            if(token == "+" ||
                token == "-" ||
                token == "*" ||
                token == "/"
            ) {
                //遇到符号则取数运算再入栈
                int val2 = st.top();
                st.pop();
                int val1 = st.top();
                st.pop();
                int res;
                res = (token == "+" ? val1 + val2 : res);
                res = (token == "-" ? val1 - val2 : res);
                res = (token == "*" ? val1 * val2 : res);
                res = (token == "/" ? val1 / val2 : res);
                st.push(res);
            }
            else {
                //其他情况就是遇到数字了，直接入栈
                st.push(stoi(token));
            }
        }
        return st.top();
    }
};
```

### 1.1.4 遇到的困难

🈚️

### 1.1.5 本题总结

是一道求后缀表达式结果的题目，相当于408数据结构的相关题目的一个步骤，写起来还是挺顺的。

---

## 1.2 239. 滑动窗口最大值

- 原文链接：[代码随想录](https://programmercarl.com/0239.滑动窗口最大值.html#_239-滑动窗口最大值)
- 题目链接：[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

### 1.2.1 题目描述

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

**提示：**

-   `1 <= nums.length <= 105`
-   `-104 <= nums[i] <= 104`
-   `1 <= k <= nums.length`

### 1.2.2 初见思路

同样任务里说建议先看视频讲解，那就先看一遍。

### 1.2.3 正式做题

经过讲解，学习到了本题可以直接使用单调队列来做。

单调队列主要是可以维护队列的最大值一定在队头，每次插入值的时候比插入值小的元素全都pop掉，因为它们不可能是最大值。如果出现了多个最大值的情况，那么显然应该是都保留的，这样可以多pop几次，符合直觉。

实现上面的功能就需要借助双端队列来实现了，这个单调队列的代码如下：

```cpp
class MonotonicQueue {
private:
    deque<int> dq;
public:
    int pop(int x) {
        //如果刚好要pop队头元素，那就真pop
        if (!dq.empty() && dq.top() == x) {
            int res = dq.front();
            dq.pop();
            return res;
        }
        //否则什么也不做
        return x;
    }
    int push(int x) {
        //如果发现队尾元素比 x 小，则pop_back
        while (!dq.empty() && dq.back() < x) {
            dq.pop_back();
        }
        dq.push_back(x);
    }
    int getMax() {
        return dq.front();
    }
};
```

然后就是主函数实现部分了，这里就不单独写了，下面是完整代码：

```cpp
class Solution {
private:
    class MonotonicQueue {
    private:
        deque<int> dq;
    public:
        void pop(int x) {
            //如果刚好要pop队头元素，那就真pop
            if (!dq.empty() && dq.front() == x) {
                int res = dq.front();
                dq.pop_front();
            }
            //否则什么也不做
        }
        void push(int x) {
            //如果发现队尾元素比 x 小，则pop_back
            while (!dq.empty() && dq.back() < x) {
                dq.pop_back();
            }
            dq.push_back(x);
        }
        int getMax() {
            return dq.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MonotonicQueue* mq = new MonotonicQueue;
        vector<int> res;
        //先完成第一步的入队，把窗口弄出来
        for (int i = 0; i < k; i++) {
            mq->push(nums[i]);
        }
        res.push_back(mq->getMax());
        //之后进入正常的循环
        for (int i = 0; (i + k) < nums.size(); i++) {
            mq->pop(nums[i]);
            mq->push(nums[i + k]);
            res.push_back(mq->getMax());
        }
        delete mq;
        return res;
    }
};
```

### 1.2.4 遇到的困难

由于是直接看视频的，所以本题没有思路上的卡壳，对视频里提到的 C++ 优先级队列这个东西我还不知道，后面再学一下。

### 1.2.5 本题总结

非常有意思的思路，记下来！

---

## 1.3 347.前 K 个高频元素

- 原文链接：[代码随想录](https://programmercarl.com/0347.前K个高频元素.html#_347-前-k-个高频元素)
- 题目链接：[347. 前 K 个高频元素 - 力扣（LeetCode）](https://leetcode.cn/problems/top-k-frequent-elements/description/)

### 1.3.1 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

-   `1 <= nums.length <= 105`
-   `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
-   题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：** 所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

### 1.3.2 初见思路

直接用哈希表法就能做，先写一版，肯定不是这道题的标准答案：

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> myMap;
        vector<int> res;
        int maxCount = 0;
        for (int num : nums) {
            myMap[num]++;
        }
        vector<pair<int,int>> vec(myMap.begin(), myMap.end());
        sort(vec.begin(), vec.end(), [](const pair<int, int>& a, const pair<int,int>& b) {
            return a.second > b.second;
        });
        for (int i = 0; i < k; i++) {
            res.push_back(vec[i].first);
        }
        return res;
    }
};
```

### 1.3.3 正式做题

看了视频知道了我上面的方法时间复杂度是 $O(n\log{n})$，而使用堆的方法可以达到 $O(n\log{k})$ 的，当 k << n 的时候，那么两个方法的时间复杂度差异就非常明显了，因此这个方法是很有必要掌握的。

这道题的思路是这样的，首先和我第一步一样，就是先用一个 map 来统计每个元素出现的频率，之后开一个堆，然后将 map 里的键值对依次放入，每次放完检查堆的大小，超过 k 则 pop 掉堆顶元素，使用小根堆则可以保证最后留下的 k 个元素就是最大的 k 个元素。本题对我的难点在于我对优先级队列的语法并没有掌握，因此这一部分是我本次刷题的重点。

这里直接拿给的代码分析：

首先定义一个比较器：

```cpp
class mycomparison {
public:
	bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
		return lhs.second > rhs.second;
	}
}
```

分析一下这段代码，比较规则是将两个键值对的值做比较，因为值里存放的是频率，这个很合理，然后是 `return lhs... > rhs...` ，这里的返回值表示，如果返回 true，说明父节点大于子节点，则应当调换位置，因此最终形成一个小顶堆。

之后就是定义一个优先级队列，用上前面写的比较器：

```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
```

这里三个参数分别为：

- `pair<int, int>` 表示队列里的元素。
- `vector<pair<int, int>>`表示队列的底层容器。
- `mycomparison` 是前面定义的比较器。

前面准备工作做完了，就可以开始写第一部分的逻辑：用 map 将元素频率统计出来。

```cpp
unordered_map<int, int> map;
for(int i = 0, i < nums.size(), i++) {
	map[nums[i]]++;
}
```

然后就是将这些 pair 一个一个放进优先级队列，并按需 pop 掉堆顶。

```cpp
for(unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
	pri_que.push(*it);
	if (pri_que,size() > k) {
		pri.que.pop();
	}
}
```

之后就是收尾工作，将优先级队列里的结果拿出来返回掉就可以：

```cpp
vector<int> result(k);
for (int i = k - 1; i >= 0; i--) {
	result[i] = pri_que.top().first;
	pri_que.pop();
}
return result;
```

现在题解的代码已经学习一遍了，下一步就是按照回忆自己独立在力扣上写。

[347. 前 k 个高频元素](../../编程学习/Leetcode/力扣刷题记录/347.%20前%20k%20个高频元素.md)

### 1.3.4 遇到的困难

C++ 这一块的语法基本知识没有掌握好，导致这一块花了很多时间，不过没关系，这里继续多学就可以。

### 1.3.5 本题总结

第一次接触优先级队列，也就是 C++ STL 中使用堆的方式。

# 二、总结与回顾

在算法之外的语法部分花了不少时间，可见自己这方面的薄弱，应尽快补上。

这里再补充一下栈与队列部分的总结吧：

学习这一章节，首先是栈与队列都不是容器，而是容器适配器，他们都有底层容器来实现。因此直接问比如说栈的元素是连续分布的吗，那就要考虑栈的底层容器是什么，vector就不是连续的，deque也是不连续的，list可能就是连续的。

之后分别写了用栈模拟队列以及用队列模拟栈的题目，两道题目看似关联实际上思路完全不一样。

之后就是栈的一些经典应用，主要是处理一些前后元素匹配的问题，如括号匹配，字符串去重。另外栈可以用来实现递归。递归调用就是把函数的局部变量、参数值、返回地址等压入栈中，返回的时候再弹出来。

然后就是今天的三道题目，第一道是后缀表达式，也是栈的经典应用，之后是队列的题目：滑动窗户最大值，这道题思路很灵活，用到了单调队列；最后是求 K 个高频元素，用到了优先级队列，实际上就是一个小顶堆，可以比 sort 获得更好的性能。