[TOC]

# 题目描述

**题目描述**

考虑一个简单的图形类层次结构，包括基类 Shape 和两个派生类 Rectangle 和 Circle。每个类都有一个用于计算面积的方法。你的任务是编写一个程序，根据输入数据创建一个图形对象，然后计算并输出其面积。

**输入描述**

输入包括多行，每行包含一个图形的描述。 描述的第一个单词是图形类型（"rectangle"或"circle"），然后是与该图形相关的参数。 对于矩形，参数是宽度和高度，对于圆形，参数是半径。输入以单词 "end" 结束。

**输出描述**

对于每个图形描述，输出其类型和面积。使用两位小数点精度输出面积。

**输入示例**

```
rectangle 5 3
circle 2
end
```

**输出示例**

```
Rectangle area: 15.00
Circle area: 12.56
```

**提示信息**

长方形面积的计算 = 长 * 宽

圆形面积的计算 = 3.14 * 半径 * 半径

# 编程小课

在刷题过程中面向对象使用的比较少，但是工程化开发中。面向对象却是很重要的内容，本节课我们借助一道题目学习 Python 中面向对象的一些知识，你也可以使用简易的方法轻松的解决本道题目，但是我们更希望你对类和面向对象中的三大特性：封装、继承、多态面向对象中的三大特性：封装、继承、多态有更多的了解。

## 类

在链表章节中，我们学习了类和对象（实例）的定义，现在我们先来回顾一下类的基本写法

```python
class 类名:
    公共的属性...
    
    # 对象的初始化方法，初始化一些属性
    def __init__(self, ...):
        # pass
    # 其他的方法
    def method_1(self, ...):
        # pass
        
# 创建类的实例
instance1 = 类名(参数)
# 调用类的方法
instance1.method_1(参数)
```

## 封装

封装是面向对象的三大特性之一，封装的主要目的是为了保证数据的安全性，我们假设有一个“圆形”的类 `Circle`，它具有半径 `radius` 这个属性。

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius
```

然后我们创建一个圆对象`circle`

```python
circle = Circle(5) # 创建一个对象，半径为5
```

但是这样，外部代码可以直接访问和修改半径，甚至将其设置为负数，这样的设计显然是不合理的。

```python
# 外部代码没有经过验证可以直接访问和修改半径
circle.radius = -10
```

为了防止这些问题的发生，我们可以通过封装隐藏对象中一些不希望被外部所访问到的属性或方法，具体怎么做呢？可以分为两步：

- 将对象的属性名，修改为一个外部不知道的名字
- 提供`getter`和`setter`来获取和设置对象的属性

> 一般情况下，对于对象的隐藏属性，使用双下划线开头：`__xxx`

```python
class Circle:
    def __int__(self, radius):
        # 1. 将属性名，修改为一个外部不知道的名字
        self.__radius = radius # 使用双下划线前缀将属性私有化
    # 2. 定义get方法，获取属性
    def get_radius(self):
        return self.__radius
    # 2. 定义set方法，设置属性
    def set_radius(self, radius):
        self.__radius = radius
        
circle = Circle(5) # 创建一个对象，半径为5
# 只有通过对应的方法，才能修改属性
circle.set_radius(10)
```

使用封装，我们隐藏了类的一些属性，具体的做法是使用 `getter` 方法获取属性，使用 `setter` 方法设置属性，如果希望属性是只读的，则可以直接去掉 setter 方法，如果希望属性不能被外部访问，则可以直接去掉 getter 方法。

此外我们还可以在读取属性和修改属性的同时做一些其他的处理，比如如下的操作：

```python
def set_radius(self, radius):
    if radius > 0:
        self.__radius = radius
circle.set_radius(-10) # 不会成功设置radius属性
```

## 继承

在对象中，总有一些操作是重复的，比如说 `Person` 类具有姓名、身高、年龄等特征，并具有一些行走、吃饭、睡觉的方法，而我们要实现一个 `Teacher` 类，`Teacher` 首先也是一个人，他也基本人的特征和方法，那我们是不是也应该用代码去实现这些特征和方法呢，这就势必会产生一些重复的代码。

因此，我们可以采用“继承”的方式使得一个类获取到其他类中的属性和方法。在定义类时，可以在类名后的括号指定当前类的父类（超类), 子类可以直接继承父类中的所有属性和方法，从而避免编写重复性的代码，此外我们还可以对子类进行扩展。

假设，我们有一个图形类 `Shape` , 它具有两个属性和一个方法，属性为颜色和类型，方法为求图形的面积

```python
class Shape:
    # 包含颜色和类型两个属性
    def __init__(self, shape_type, color):
        self.type = shape_type
        self.color = color
    # 计算图形面积的方法
    def calculate_area(self):
        # pass表示空语句，不需要执行任何操作
        pass
shape = Shape('shape', 'white')
```

我们还需要一个关于圆的类，它继承自 `Shape` 类

```python
# 传入Shape, 表示基础自Shape类
class Circle(Shape):
    def __init__(self, shape_type, color, radius):
        super().__init__(shape_type, color)
        self.radius = radius
    # 计算圆的面积
    def calculate_area(self):
        return 3.14 * self.radius * self.radius
      
circle = Circle('circle', 'white', 10)
# 计算圆的面积
circle.calculate_area()
```

在上面的示例代码中，图形类拥有两个属性和一个方法，圆的类在图形类的基础上添加了半径这个属性。

```python
super().__init()
```

父类和子类中含有一些共同属性，在重写子类时，为了省略重复的代码，可以通过 `super()` 动态的获取当前类的父类, 并调用父类的 `__init__()` 方法从而初始化父类中定义的属性。

在子类和父类中都有 `calculate_area` 这个方法，这被称为方法的重写，子类会调用自己的方法而不是父类的方法。如果子类的对象调用一个方法，发现并没有提供这个方法，就会从当前对象的父类中寻找，如果父类中有则直接调用父类中的方法，如果还没有，就从父类的父类中寻找，就好像，当父亲和儿子都拥有一样东西，会优先使用自己的，如果发现自己没有，才会使用继承的方法。

## 多态

多态常常和继承紧密相连，它允许不同的对象对方法调用做出不同的响应。你可以使用基类定义通用的代码，然后在派生类中提供特定的实现，从而在调用方法时调用不同的方法，比如下面的示例：

```python
class Shape:
    # 基类的计算面积的方法
    def calculate_area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
        # Circle类的计算面积的方法
    def calculate_area(self):
        return 3.14 * self.radius * self.radius

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        # Rectangle类的计算面积的方法
    def calculate_area(self):
        return self.width * self.height

# 创建不同类型的图形对象
circle = Circle(2)
rectangle = Rectangle(4, 3)

# 存放图形对象的列表
shapes = [circle, rectangle]

# 计算面积
for shape in shapes:
    # 列表中的每个元素都调用计算面积的方法
    area = shape.calculate_area()
    # 输出面积
    print(f"Area: {area:.2f}")
```

在上面的代码示例中，基类  `Shape` 实现了 `calculate_area` 方法, 两个派生类  `Circle` 和 `Rectangle` 则是重写了 `calculate_area` 方法，它们有着不同的计算逻辑。之后我们创建了一个包含不同类型的图形对象的列表  `shapes`，然后循环遍历该列表并调用  `calculate_area`  方法，尽管方法名称相同，但实际调用的方法是根据对象的类型动态确定的，这其实就是多态的概念。

## 代码编写

我们之前已经做了很久的铺垫，根据题目要求，`Shape` 类应该具有一个属性 `type` 和一个方法 `calculate_area` 用了计算面积

```python
class Shape:
    def __init__(self, shape_type):
        self.type = shape_type
     
    def calculate_area(self):
        pass
```

之后，我们需要实现两个类 `Rectangle` 和 `Circle`，它们都继承自类 `Shape`

```python
class Rectangle(Shape):
    def __init__(self, width, height):
        super().__init__("Rectangle")
        self.width = width
        self.height = height
 
    def CalculateArea(self):
        return self.width * self.height
 
class Circle(Shape):
    def __init__(self, radius):
        super().__init__("Circle")
        self.radius = radius
 
    def CalculateArea(self):
        return 3.14 * self.radius * self.radius
```

之后，我们可以定义一个列表，用来放置建立的示例，并处理输入输出

```python
shapes = []
 
while True:
    data = input().split()
    # 获取输入的类型
    shape_type = data[0]
```

对输入的类型进行判断，如果是"end", 终止程序，如果是图形，则建立对应的实例

```python
# 处理type = "end"的情况
if shape_type == "end":
        break
# 处理 type = "rectangle"的情况，获取宽和高，并新建实例，append()到列表中
if shape_type == "rectangle":
    width, height = float(data[1]), float(data[2])
    shapes.append(Rectangle(width, height))
# 处理 type = "circle"的情况，获取半径，并新建实例，append()到列表中
elif shape_type == "circle":
    radius = float(data[1])
    shapes.append(Circle(radius))
```

最后, 遍历列表，并输出面积即可

```python
for shape in shapes:
    print(f"{shape.type} area: {shape.calculate_rea():.2f}")
```

完整的代码如下：

```python
# Shape类
class Shape:
    def __init__(self, shape_type):
        self.type = shape_type
     
    def calculate_area(self):
        pass
#  Rectangle类，包含 width 和 height, 计算面积的方法
class Rectangle(Shape):
    def __init__(self, width, height):
        super().__init__("Rectangle")
        self.width = width
        self.height = height
 
    def calculate_area(self):
        return self.width * self.height
# Circle类，包含 radius, 计算面积的方法 
class Circle(Shape):
    def __init__(self, radius):
        super().__init__("Circle")
        self.radius = radius
 
    def calculate_area(self):
        return 3.14 * self.radius * self.radius
         
shapes = []
 
while True:
    data = input().split()
    shape_type = data[0]
    # 处理输出
    if shape_type == "end":
        break

    if shape_type == "rectangle":
        # 获取输入的width/height, 将之转换成整数
        width, height = int(data[1]), int(data[2])
        # 新建一个对象，append到列表中
        shapes.append(Rectangle(width, height))
    elif shape_type == "circle":
        # 获取输入的radius, 将之转换成整数
        radius = int(data[1])
        # 新建一个对象，append到列表中
        shapes.append(Circle(radius))
 
for shape in shapes:
    # 不同类别的对象调用同一个方法，有不同的处理逻辑
    print(f"{shape.type} area: {shape.calculate_area():.2f}")
```

## 总结

本节课中，我们学习到了类的使用，并对面向对象的三大特性，封装、继承、多态有了一些理解。总结来说，封装确保了对象中的数据安全，继承使得代码更加简洁，而且保证了对象的可扩展性，而多态则保证了程序的灵活性，不同的对象调用同一个方法有不同的响应。

Python 语言小课到这里就结束了，回顾一下，我们还是接触了很多内容的。

## 语言知识

- 输入和输出
- 变量
- 数据类型和数据类型转换
- 循环： for 、range、while
- 多重赋值、元组解构
- 模块
- 条件判断、break、continue
- 条件运算、关系运算、逻辑运算符、算术运算、赋值运算
- 常用的数学运算、取模运算、整数除法
- 列表的概念、索引访问、遍历和常用方法
- 切片操作
- 序列：列表、字符串、元组
- 可变值和不可变值
- 二维列表的遍历和循环嵌套
- 字符串的创建、索引、元素的访问以及遍历操作
- 字符串的常用方法、字符串大小转换
- 格式化字符串
- `flag`编程思想
- 函数的定义、形参和实参
- 面向对象、类和实例、属性和方法
- `self`和`__init__`特殊方法
- 集合的概念、特点和常用方法
- 字典的概念、特点和常用方法
- 栈的概念、特点和常用方法
- 队列的概念、特点和常用方法

## 数据结构

此外，我们还接触了一些基本的数据结构，它们会在后面的刷题之旅中经常使用。

- 列表
- 字符串
- 链表
- 哈希表
- 栈
- 队列

## 最后

通过以上知识的学习，大家在刷题的时候，基本解决语言方面的问题了，此时就需要更专注于算法知识的学习，接下来大家去刷[代码随想录](https://www.programmercarl.com/)，那里有新的挑战在等着你！

最后也希望大家可以写一篇总结博客（博客可以是 CSDN，知乎，掘金，甚至小红书都行），来记录这一刻吧，加油💪

> 如果认可本课程，想成为本课的分销代理（就是通过你的链接购买本课的话，你会得到佣金），可以发卡哥邮箱：[programmercarl@163.com](mailto:programmercarl@163.com)，说明自己的背景（学校，年级，校园活动等等），为什么想成为本课的销售代理，以及自己的微信联系方式。审核通过后，会给你开通。

# 代码：

```python
class Shape:
    def __init__(self, shape_type):
        self.__shape_type = shape_type
    def calculate_area(self):
        pass


class Rectangle(Shape):
    def __init__(self, x, y):
        super().__init__("rectangle")
        self.x = x
        self.y = y
    
    def calculate_area(self):
        return self.x * self.y

class Circle(Shape):
    def __init__(self, r):
        super().__init__("circle")
        self.r = r
    
    def calculate_area(self):
        return 3.14 * self.r * self.r
    
while True:
    data = input().split()
    if data[0] == 'end':
        break
    elif data[0] == 'rectangle':
        shape = Rectangle(int(data[1]), int(data[2]))
        print(f"Rectangle area: {shape.calculate_area():.2f}")
    elif data[0] == 'circle':
        shape = Circle(int(data[1]))
        print(f"Circle area: {shape.calculate_area():.2f}")
```

