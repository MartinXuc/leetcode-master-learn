[TOC]

# 题目描述

**题目描述**

请编写一个程序，实现以下操作： 

构建一个单向链表，链表中包含一组整数数据，输出链表中的第 m 个元素（m 从 1 开始计数）。 

要求：

1. 使用自定义的链表数据结构
2. 提供一个 linkedList 类来管理链表，包含构建链表、输出链表元素以及输出第 m 个元素的方法
3. 在 main 函数中，创建一个包含一组整数数据的链表，然后输入 m，调用链表的方法输出第 m 个元素

**输入描述**

第一行包含两个整数 n 和 k，n 表示需要构建的链表的长度，k 代表输入的 m 的个数。 

接下来一行包含 n 个整数，表示链表中的元素。 

接下来一行包含 k 个整数，表示输出链表中的第 m 个元素。

**输出描述**

测试数据输出占 k 行。 

每行输出链表中的第 m 个元素。如果 m 位置不合法，则输出“Output position out of bounds.”。

**输入示例**

```
5 5
1 2 3 4 5
4 3 2 9 0
```

**输出示例**

```
4
3
2
Output position out of bounds.
Output position out of bounds.
```

# 编程小课

## 前言

本节课我们将通过输出第 m 个元素的操作加深对链表的理解。

## 代码编写

依旧先把代码的基础结构给搭建好，上节课我们已经学习了如何定义链表和链表节点，以及链表插入和打印链表的函数，这些内容都是“模板”写法，在本节内容中依旧如此定义。我们只需要拿来稍加修改即可。

```python
# 链表节点定义
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
# 链表类定义
class LinkList:
    def __init__(self):
        self.head_node = None
        self.length = 0
    # insert 方法用于插入数据
    def insert(self, data):
        self.length += 1
        new_node = Node(data)
        if self.head_node is None:
            self.head_node = new_node
            return self.head_node
        else:
            current_node = self.head_node
            while current_node.next is not None:
                current_node = current_node.next
            current_node.next = new_node
            return new_node
```

然后我们需要读取 n 和 k，n 表示需要构建的链表的长度，k 代表输入的 m 的个数，并构建一个新的链表。

```python
n,k = map(int, input().split())
link_list = LinkList()
```

和上一节内容相似，依旧需要使用`for` 循环，迭代读取 `n` 个整数，然后使用之前定义的`insert`函数将新的链表节点插入到链表尾部，从而根据读入的数据构建一个完整的链表。

```python
elements = list(map(int, input().split()))
for data in elements:
    link_list.insert(data)
```

上面的操作完成之后，链表就成功构建了，我们需要根据题目要求读取 k 个 `m` ，并输出这 k 个值， 如果输入的 m 是一个小于等于 0 的数或者 m 大于链表的长度，则无法找到第 m 个节点，判定 m 位置不合法，输入对应的语句。

![](assets/第%2014%20题%20链表的基础操作%20II/image-20231106113033244.png)

```python
for m in m_values: # k 次循环
    if m < 1 or m > link_list.length: # m 位置不合法，输出对应的语句
        print("Output position out of bounds.")
    else: # m 位置合法，找到第 m 个节点
```

每次找到第 m 个节点都需要从头节点开始遍历，所以将 `currentNode` 重新指向头结点，以便重新遍历链表。

```python
current_node = link_list.headNode # currentNode 指向头节点
```

使用 `for` 循环，寻找链表中的第 `m` 个元素，只需控制走 m - 1 步即可。

```python
# 可以用 m = 2 来模拟，想要找到第 2 个节点，只需走一次 
for _ in range(m - 1):
    current_node = current_node.next # 指向下一个节点
# 当循环结束后，打印节点的值即可。
print(current_node.data)
```

完整代码如下：

```python
# 定义链表节点
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
# 定义链表
class LinkList:
    def __init__(self):
        self.headNode = None
        self.length = 0

    def insert(self, data):
        self.length += 1
        new_node = Node(data)
        if self.headNode is None:
            self.headNode = new_node
            return self.headNode
        else:
            current_node = self.headNode
            while current_node.next is not None:
                current_node = current_node.next
            current_node.next = new_node
            return new_node


n, k = map(int, input().split())
# 新建链表实例
link_list = LinkList()
elements = list(map(int, input().split()))
# 将输入数据插入到链表中
for data in elements:
    link_list.insert(data)
# 获取输入的 m 
m_values = list(map(int, input().split()))

for m in m_values:
    # 如果 m 位置不合法
    if m < 1 or m > link_list.length:
        print("Output position out of bounds.")
    else:
        # 找到第 m 个节点
        current_node = link_list.headNode
        for _ in range(m - 1):
            current_node = current_node.next
        # 输出第 m 个节点的值
        print(current_node.data)
```

## 寻找第 n 个节点的方法

其实可以将寻找第 m 个节点和`insert`方法一样，定义为链表类的一个方法，方法需要接收一个参数

```python
# get方法用于查找 第 n 个节点
def get(self, n):
    # 如果 n 小于 1 或者 大于链表的长度，返回 None
    if n < 1 or n > self.length:
        return None
    i = 1
    # 从头节点开始遍历
    current_node = self.head_node
    while current_node is not None:
        if i == n: #  i == n 的时候 找到第 n 个节点
            return current_node
        i += 1 # i 的值 + 1
        current_node = current_node.next # 移动 current_node指针，转为下一个节点
    # 没有找到第 n 个的节点的情况下，返回 None
    return None
```

然后在对应的位置调用`get`方法即可。

```python
m_values = list(map(int, input().split()))
for m in m_values:
    node = link_list.get(m) # 调用 get 方法，获取第 m 个节点
    if node is not None: # 如果节点 不为 None, 输出对应的 data
        print(node.data)
    else: # 否则，则为 m 位置不合法
        print("Output position out of bounds.")
```

完整的代码如下：

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkList:
    def __init__(self):
        self.head_node = None
        self.length = 0

    def insert(self, data):
        self.length += 1
        new_node = Node(data)
        if self.head_node is None:
            self.head_node = new_node
            return self.head_node
        else:
            current_node = self.head_node
            while current_node.next is not None:
                current_node = current_node.next
            current_node.next = new_node
            return new_node
    # 获取第 n 个节点的方法
    def get(self, n):
        # 输入位置不合法
        if n < 1 or n > self.length:
            return None
        i = 1
        current_node = self.head_node
        while current_node is not None:
            # 找到第 n 个节点
            if i == n:
                return current_node
            i += 1
            current_node = current_node.next
        return None

n, k = map(int, input().split())
link_list = LinkList()
elements = list(map(int, input().split()))

for data in elements:
    link_list.insert(data)
    
m_values = list(map(int, input().split()))
for m in m_values:
    node = link_list.get(m) # 调用 get 方法，获取第 m 个节点
    if node is not None: # 如果节点 不为 None, 输出对应的 data
        print(node.data)
    else: # 否则，则为 m 位置不合法
        print("Output position out of bounds.")
```

## 结语

本节课我们通过输出链表第 m 个元素练习了链表节点的定义和链表的插入和遍历操作，这些基本操作在链表相关的题目中是不可缺少的，大家一定要多多练习。
