[TOC]

# 题目描述

**题目描述**

构建一个单向链表，链表中包含一组整数数据。输出链表中的所有元素。

要求：  
1. 使用自定义的链表数据结构  
2. 提供一个 linkedList 类来管理链表，包含构建链表和输出链表元素的方法  
3. 在 main 函数中，创建一个包含一组整数数据的链表，然后调用链表的输出方法将所有元素打印出来

**输入描述**

包含多组测试数据，输入直到文件尾结束。 

每组的第一行包含一个整数 n，表示需要构建的链表的长度。 

接下来一行包含 n 个整数，表示链表中的元素。

**输出描述**

每组测试数据输出占一行。 
按照顺序打印出链表中的元素，每个元素后面跟一个空格。

**输入示例**

```
5
1 2 3 4 5
6
3 4 5 6 7 8
```

**输出示例**

```
1 2 3 4 5
3 4 5 6 7 8
```

**提示信息**

数据范围：

1 <= n <= 1000;

# 编程小课

## 前言

在之前的学习中，我们接触到了字符串和数组 (列表) 这两种结构，它们具有着以下的共同点

- 元素按照一定的顺序来排列
- 可以通过 **索引** 来访问数组中的元素和字符串中的字符

但是它们也都有着一些缺点：

- 固定大小：数组的大小通常是固定的，一旦分配了内存空间，就难以动态地扩展或缩小，如果需要存储的元素数量超出了数组的大小，就需要重新分配更大的数组，并将原来数组的内容复制过去，需要执行很多额外的操作(Python中的列表是动态扩容的，但是在大多数语言中，数组的大小固定)。
- 内存是连续的：正是因为元素按照一定的顺序来排列，它们在计算机内存中的存储也是连续的，这也就意味着，当需要存储一些需要占用空间较大的内容，也只能找一些大块的内存区域，而空间比较小的内存区域就利用不起来，从而导致了内存资源浪费。
- 固定的数据类型：数组要求所有元素具有相同的数据类型，字符串存储的都是字符，如果需要存储不同类型的数据，数组和字符串就显得无能为力了。

还有重要的一点是，如果我们想要往数组中新增加或者删除一个元素，会特别麻烦！

> 我们可以通过特定的方法执行新增或删除操作，这看起来十分简单，但是在计算机内部，频繁的操作会比较耗时。

比如下面的图例，想要往数组中删除第三个元素，当完成删除后，还需要从删除元素位置遍历到最后一个元素位置，分别将它们都向前移动一个位置，也就是说后续的所有元素都要改变自己的位置，这是十分耗时的操作。

![](assets/第%2013%20题%20链表的基础操作%20I/image-20230908160231538-7618638-8907691.png)

那有没有什么数据结构能够解决上面的问题呢？

那就是我们这节课中将要学习到的链表！

## 链表

与数组不同，链表的元素存储可以是连续的，也可以是不连续的，每个数据元素处理存储本身的信息（`data数据域`）之外，还存储一个指示着下一个元素的地址的信息（`next指针域`），给人的感受就好像这些元素是通过一条“链”串起来的。

![](assets/第%2013%20题%20链表的基础操作%20I/image-20231106102633305.png)

链表的第一个节点的存储位置被称为**头节点**，然后通过 `next` 指针找到下一个节点，直到找到最后一个节点，最后一个节点的 `next` 指针并不存在，也就是“空”的，在 Python 中，用 `None` 来表示。

关于链表，更为详细的可以看这里[链表理论基础](https://programmercarl.com/链表理论基础.html#链表的类型)

## 面向对象

Python是一门面向对象的编程语言, 该怎么理解这句话呢？

这里的“对象”实际上是对现实世界中所存在的事物的一种抽象，举个例子，你在计算机世界中怎么表示“人”这个概念呢？

人拥有着一些静态的特征，比如身高、体重、性别等，也拥有一些动态的行为，比如吃法，睡觉等，而在计算机世界中，我们将之抽象为一个类 `Person` , 并具有与之对应的“属性”和“方法”。

- “属性”表示 `Person` 类所具有的特征，比如姓名、年龄、性别，通过这些特征，我们可以描述一个“人”的基本状态。
- “方法”表示 `Person` 类的行为和功能，比如吃饭、睡觉、行走，通过这些动作，我们可以描述一个“人”的动态行为。

比如下面的“伪代码”表示 `Person` 类的定义, 它包括姓名、性别、年龄和吃饭的方法。

```
Person:
    // 姓名、性别、年龄等属性
    name
    gender
    age
    // 吃饭的方法
    eat
    // 行走的方法
    walk
}
```

这样在计算机世界，一个“人”的概念就建立起来了，但这里的 `Person` 类只是个“模具”，空有概念，而无法表示具体的某一个人，只有创造一个类的**实例**（也就是我们说的对象），比如"张三，18， 男", "李明、20，男"，才能真正的使用。

```python
# 实例化一个类,从而创造一个对象，和调用一个函数类似
person1 = Person("Tom", 10, "男") # person1是一个对象，是Person类的实例
person2 = Person("Jerry", 3, "男")# person2是一个对象，是Person类的实例
```

现在你是不是能对面向对象有一些初步的理解了呢？

简而言之，“类”是现实世界中的实体在计算机世界中的抽象概念，类可以看作是对象的模板，它定义了对象的结构和行为方式，而对象是“类”的实现。

## Class类

在了解了 Python 类和对象的基本概念之后，我们开始尝试编写一些简单的类的代码，如果你之前没有接触过面向对象，可能很难去理解为什么要这样写，但是没关系，编程最开始往往是从“死记硬背”开始的，后面我们会进行详细的解释，从而帮助你更好的理解它。

在 Python 中，类的定义是从 `class` 关键字开始的, 类的名称命名要使用大驼峰来命名（即 `MyName` 这种形式）

```python
class Person:
```

在类的代码块中，我们可以定义变量和函数，在类中所定义的变量，将会成为所有的实例的属性，所有实例都可以访问这些变量，在类中也可以定义函数（被称之方法），类的所有实例也可以访问这些方法。

```python
class Person:
    # 类中定义一个变量 name, 会成为所有实例的公共属性
    name = "Tom"
    # 类中也可以定义函数，称之为方法，方法也可以通过该类的实例来访问
    def say_hello(self):
        print("Hello")
        
# 创建Person的实例    
person1 = Person()
person2 = Person()

# 实例可以调用属性
person1.name = "Jerry"
person2.name = "Mike"

# 实例可以调用方法
person1.say_hello()
person2.say_hello()
```

类中的方法每次被调用时，Python 都会自动帮我们传递一个参数，表示调用方法的对象本身（也就是创建的实例），一般我们将这个参数命名为 `self`。

在上面的操作中，我们定义了 `name` 属性在类中，以方便实例使用，但是这样会把属性的“值”固定下来，我们创建的 `person、person2` 实例，它们的 `name` 值都是一样的，然后不同的对象实例，其属性值应该是不同的，这就需要使用到特殊方法 `__init__`，用来初始化属性

```python
class Person:
    # 定义__init__方法，name是创造实例时传递的参数
    def __init__(self, name):
        # self表示实例本身，即实例.name属性 = 传递的name值
        self.name = name
```

`__init__` 方法会在实例创建的时候立即执行，可以向新创建的对象初始化属性，调用类创建对象时，类后边的所有参数都会依次传递到 init 中。

```python
# "Mike"值传递给__init__(self, name）中的name, 进行通过self.name = name给实例添加name属性
person1 = Person("Mike") 
```

经过上面知识的学习，我们已经知道Python中类的基本结构是如下形式的：

```python
class 类名:
    # 公共属性
    # init方法
    def __init__(self, 其他参数):
      
    # 其他方法
    def method_1(self, 其他参数):
    ...
```

## 定义链表节点

那在 Python 语言中如何定义链表节点呢，由链表节点的概念我们可以知道，一个链表节点包含一个数据元素和一个指向下一个节点的指针，即包括一个数据字段和一个节点字段，初始化一个新节点，其 `next` 通常不存在，即一个空值，`None`  可以用于初始化或重置对象的属性，以表明属性当前为空或者没有设置，新创建的节点其 next 都为 `None`。

```python
# 定义链表节点类
class Node:
    # init方法，初始化属性
    def __init__(self, data):
        self.data = data # 存储节点的数据
        self.next = None # next指针初始化为None
```

然而上面的代码只是声明了一个链表节点，一个链表是有 0 到 多个链表节点构成的，我们还需要定义一个链表类用于容纳链表节点，链表类一般包括链表头节点和链表的节点长度这两个属性。

```python
# 定义链表类
class LinkList:
    def __init__(self):
    # 链表头节点，初始化为None
        self.head_node = None
        # 链表长度，初始化为0
        self.length = 0
```

## 链表的插入

上面我们完成了定义链表和链表节点的操作，但是这个链表并没有提供对应的方法使我们将一个节点插入到链表中，从而形成一个完整的链表。

接下来，我们就定义一个方法，接收传入的数据，并构建一个新的节点，插入到链表的尾部，具体步骤如下：

- 新加入一个节点，所以链表长度 `length` + 1
- 创建一个新的链表节点，初始化它的值为 `data`
- 如果当前链表还是空链表（头节点为空），则新创建的链表节点为头节点
- 如果当前链表不为空链表，将新的节点放入到链表的尾部，接入链表，也就是当前链表的尾部的 `next` 指向新节点，新接入的链表节点变为链表的尾部

所以我们可以在 `LinkList` 类中定义一个 `insert` 方法，用于将传入的数据插入到链表中

```python
class LinkList:
    def __init__(self):
        self.head_node = None
        self.length = 0
    # 该方法名称为insert，接收data作为参数
    def insert(self, data):
        self.length += 1 # 链表长度 加 1
```

然后将传入的 `data` 作为参数传给 `Node` 类，新定义一个链表节点实例

```python
new_node = Node(data) # 定义一个新的链表节点
```

接下来需要将新节点插入到链表尾部，但是需要面临两种情况(这是因为需要处理头节点)，链表为空（判定条件为头节点为`None`或是链表长度为0）和链表不为空的情况。

首先处理链表为空的情况，这时候只需要将新创建的节点成为头节点，并且返回这个节点即可。

```python
# 链表为空
if self.head_node is None:
    self.head_node = new_node # 新创建的节点成为头节点
    return self.head_node # 返回头节点，程序return, 不再执行后面的代码
```

当链表不为空时，就需要找到链表的最后一个节点，将最后一个节点的`next`指向新添加的节点，但是如果找到最后一个节点呢？

这是一个固定模板操作，从头节点开始遍历，直到找到某个节点的`next`指向`None`时，说明已经走到了链表的尾部。

或者我们可以这样理解，有一份情报需要从上往下传递，接头人逐级传递，直到找不到下一级接头人时，说明情报已经传达到了尾部。

假设我们用`currentNode`指代当前已经传递到了那个节点，最初需要将其指向头节点。

```python
current_node = self.head_node # currentNode指针初始指向头节点
# 不断移动currentNode，直到 next指针为None时停止，说明已经走到最后一个节点
while current_node.next is not None: 
    # currentNode 移动到下一个节点
    current_node = current_node.next
```

此时`currentNode.next`为`None`, 说明已经指向了最后一个节点，之后将新创建的节点插入到链表的尾部，只需将最后一个节点的`next`指针指向新插入的节点即可。

![](assets/第%2013%20题%20链表的基础操作%20I/image-20231106104820564.png)

完整代码如下：

```python
class LinkList:
    def __init__(self):
        self.head_node = None
        self.length = 0
    # 该方法名称为insert，接收data作为参数
    def insert(self, data):
        self.length += 1 # 链表长度 加 1
        new_node = Node(data) # 创建一个新的链表节点，初始化值为 data
        if self.head_node is None: # 如果当前链表为空链表
            self.head_node = new_node #  新创建的链表节点为头节点
            return self.head_node
        current_node = self.head_node # 如果当前链表不是空链表, currentNode 指针初始指向 头节点
        while current_node.next is not None:
            # 不断移动 currentNode，直到 next 指针为空时停止，说明已经走到最后一个节点
            current_node = current_node.next
        current_node.next = new_node # 将新创建的节点插入到链表的尾部
        return new_node # 返回插入的节点
```

如果想要打印链表节点，操作步骤和遍历链表直到找到最后一个节点的过程相似，代码如下：

```python
# 打印链表
def print_link_list(self):
    current_node = self.head_node #  currentNode 指针初始指向 头节点
    while current_node is not None:
        print(current_node.data, end=" ") # 输出链表数据
        current_node = current_node.next # 移动 currentNode
    print()
```

## 代码编写

照例先把程序的基本结构书写出来，包含多组测试数据，所以需要一个无限循环，每组第一行接收一个整数 n , 表示需要构建的链表的长度。

然后将之前定义的链表和相关方法写上去。

```python
# 链表节点的类
class Node:
    # init方法，初始化链表节点属性，包括 data 和 next
    def __init__(self, data):
        self.data = data
        self.next = None
# 链表类
class LinkList:
    # init方法，初始化链表属性，包括头节点和链表长度
    def __init__(self):
        self.head_node = None
        self.length = 0
    # 向链表插入数据的方法
    def insert(self, data):
        self.length += 1
        new_node = Node(data)
        if self.head_node is None:
            self.head_node = new_node
            return self.head_node

        current_node = self.head_node
        while current_node.next is not None:
            current_node = current_node.next

        current_node.next = new_node
        return new_node
    # 打印链表节点的方法
    def print_link_list(self):
        current_node = self.head_node
        while current_node is not None:
            print(current_node.data, end=" ")
            current_node = current_node.next
        print()
```

之后我们需要根据输入的值构建链表，循环 n 次，将 n 次输入的数据通过`insert()`方法插入到链表中

```python
while True:
    try:
        n = int(input())  # 接收 n 的输入，表示链表的长度
        elements = list(map(int, input().split()))  # 接收链表中的元素
    except:
        break

    link_list = LinkList()  # 新建链表

    for data in elements:
        link_list.insert(data)  # 将数据插入到链表节点中
```

此时链表已经构建完毕，我们根据需求调用 `print_link_list` 函数将链表数据打印出来即可, 只不过题目有特定的输出格式，我们简单修改一下代码，保证每行数据的最后一个元素不输出空格即可。

```python
def print_link_list(self):
    current_node = self.head_node
    while current_node is not None:
        # 如果当前节点的下一个节点不是None, 说明没有到最后一个节点，输出空格
        if current_node.next is not None:
            print(current_node.data, end=' ')
        else: # 否则，只输出对应的链表节点值
            print(current_node.data)
        current_node = current_node.next
```

```python
link_list.print_link_list()  # 打印链表数据
```

完整的代码如下：

```python
# 链表节点类
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
# 链表类
class LinkList:
    def __init__(self):
        self.head_node = None
        self.length = 0
    # 尾部插入链表节点
    def insert(self, data):
        self.length += 1
        new_node = Node(data)
        if self.head_node is None:
            self.head_node = new_node
            return self.head_node

        current_node = self.head_node
        while current_node.next is not None:
            current_node = current_node.next

        current_node.next = new_node
        return new_node
   # 打印链表节点
   def print_link_list(self):
        current_node = self.head_node
        while current_node is not None:
            # 如果当前节点的下一个节点不是None, 说明没有到最后一个节点，输出空格
            if current_node.next is not None:
                print(current_node.data, end=' ')
            else: # 否则，只输出对应的链表节点值
                print(current_node.data)
            current_node = current_node.next

while True:
    try:
        n = int(input())  # 接收 n 的输入，表示链表的长度
        elements = list(map(int, input().split()))  # 接收链表中的元素
    except:
        break

    link_list = LinkList()  # 新建链表

    for data in elements:
        link_list.insert(data)  # 将数据插入到链表节点中

    link_list.print_link_list()  # 打印链表数据
```

## 结语

本节课我们学习到了链表节点的定义方式，以及在尾部插入链表节点以及链表遍历的过程，涉及到的新知识有点多，可能一时间不是很容易理解，但没关系，先知道代码的书写方式，后面我们还会通过几道题带你熟悉链表结构，从而更好的理解它。

# 我的代码

```python
# 链表节点类
class LinkedListNode:
    def __init__(self, data):
        self.data = data
        self.next = None
# 链表类
class LinkedList:
    def __init__(self):
        self.head_node = None
        self.length = 0

    # 尾插(可以用于构建链表)
    def insert(self, data):
        self.length += 1
        new_node = LinkedListNode(data)
        if self.head_node is None:
            self.head_node = new_node
            return new_node
        current_node = self.head_node
        while current_node.next is not None:
            current_node = current_node.next
        current_node.next = new_node
        return new_node

    # 打印
    def linked_list_print(self):
        current_node = self.head_node
        while current_node is not None:
            if current_node.next is not None:
                print(current_node.data, end = " ")
            else:
                print(current_node.data)
            current_node = current_node.next

# 主函数

if __name__ == "__main__":
    while True:
        try:
            n = input()
            elements = list(map(int, input().split()))
        except:
            break
        linked_list = LinkedList()
        for data in elements:
            linked_list.insert(data)
        linked_list.linked_list_print()

```

