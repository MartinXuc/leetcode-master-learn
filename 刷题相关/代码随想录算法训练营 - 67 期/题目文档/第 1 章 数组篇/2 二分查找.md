- [力扣题目链接](https://leetcode.cn/problems/binary-search/)
- [代码随想录](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

## 题目思路

二分查找主要看对边界条件的把控。个人习惯使用左闭右闭的方式。

需要设置一个 `left` 指针和一个 `right` 指针，然后计算中间指针 `mid`，通常是取 `left` 和 `right` 的平均数，根据 `target` 和 `nums[mid]` 的大小关系，更新 `left` 和 `right` 的值。

更新 `left` 和 `right` 的值时，需要考虑 `left` 和 `right` 的更新方式。

- 如果 `target` 大于 `nums[mid]`，则 `left` 更新为 `mid + 1`
- 如果 `target` 小于 `nums[mid]`，则 `right` 更新为 `mid - 1`
- 如果 `target` 等于 `nums[mid]`，则返回 `mid`

## 代码实现

```python
# python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > target:
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                return mid
        return -1
```

```cpp
// cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        int mid;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            }
            else if (nums[mid] < target) {
                left = mid + 1;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
};
```