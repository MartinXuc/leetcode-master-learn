## 找树左下角的值  

- 很多同学不理解怎么找到左下角而不会找到右下角的值，就是一个 dfs，然后到达叶子节点，也就是 left 和 right 都为 null 的时候，判断一下现在所在深度是不是大于最深的深度，如果是，更新一下答案值，而第一次到达一个新的深度时此节点就是最左边的节点。最终更新结果就是最左边且深度最大的节点的值。尽管也会遍历到同层的右侧节点，但是因为深度不比左子树的深，也不会更新，也就是同样在最底层的左子树会优先赋值给 resNode。  

## 路径总和  

- 用不用回溯 取决于修改后的变量传入下一层函数后 本层函数还需不需要它了  是需要它改变后的值还是原值  一般要原值就回溯  要修改后的值通过定义函数返回值来得到  

## 关于 构造二叉树  

- 今天涉及了二叉树的构建,这边给小伙伴的建议是一定先完全搞懂二叉树的前中后序遍历,然后一般是利用计算右子树节点数量来进行分割的,可以利用这一点总结成为一个模板哦!  
- 请问下这个前/后序和中序构造二叉树这题中，这两个代码中单层递归的边界范围考虑不太懂，为什么在前序的时候需要+1，后序的时候不需要？ 

![](../../../Attachment/imgs/0000k/1668522262486-a9543dad-9d8b-4430-96da-3c2a43ef49db.webp)

-   解答：上面的是依据中序和后序来构造，应该没问题，主要是下面的区别在于，下面是依据中序和前序来构造二叉树，+1是因为前序序列的第一个元素就是我们要在中序序列中找的分割点，+1就把它跳过去了嘛，它后面才是左右子树的内容。当然他们都遵顼的是左闭右开的原则。  
-   为什么要舍弃postorder 末尾元素，不舍弃inorder的末尾元素？ 因为后序数组的末尾元素是本轮构造的根节点  中序数组舍弃的是中间某个位置  
-   这道题还是比较多录友问的，很多是划分数组的时候出现了问题，建议看看上面的分析哦~另外，强烈建议C++录友使用额外定义一个函数，传入引用的数组以及起始下标的写法，如：  

```cpp
TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd)
```

-   这种写法可以大大降低重复构造的时间  

## 今日博客分享  

[如果我说在今日刷题之前我完全不知道根据中序和后序如何构造一颗唯一的二叉树，你会觉得我很菜嘛呜呜呜](https://www.tftree.top/632.html) 同感hh  
[day16笔记（玥玥同学）](https://blog.csdn.net/Xiaoxiaodezhuren/article/details/143807523?sharetype=blogdetail&sharerId=143807523&sharerefer=PC&sharesource=Xiaoxiaodezhuren&spm=1011.2480.3001.8118)