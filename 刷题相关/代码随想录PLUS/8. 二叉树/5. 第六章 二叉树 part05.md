## 关于 最大二叉树  

## 关于 合并二叉树  

## 关于 二叉搜索树中的搜索  

- 二叉搜索树->中序遍历搞定一切问题！！一定要利用这个特性！  
- 一个技巧：二叉搜索树自己设置一个pre节点+中序其实就相当于遍历一个有序链表了  
- 有同学问为什么很多题不用迭代做，其实大多数题都是用递归是最直观简单好写的，如果用迭代写本质上也是栈去模拟递归的过程，不是那么好写，所以大多数题掌握递归法就够可以了。除了最基本的前中后序遍历可以把迭代法学一下，其他的题目主要掌握递归就可以了，也是够面试用的了。  
- 解题代码中return的是一个节点，但是输出的却是一整个子树，例如截图中的，输出的应该只有一个2，但是却把2 1 3都输出了，这是怎么回事呢？ 力扣中我们写的只是一个功能函数  这个函数会在主函数中被调用 然后力扣会在主函数中以特定的顺序遍历打印出这个节点的val值和它所有的子节点的val值  

## 关于 验证二叉搜索树  

- pre变量的作用：这个就是记录二叉搜索树中当前节点的前一个用来比较的节点，当从左子树最大的一个节点回溯到当前节点时，那就是用左子树的最大的节点和当前root比较；然后pre被root赋值，又用于右子树最小的一个节点用于比较，就是判断 if (pre != NULL && pre->val >= root->val) return false;类似中序，你按中序那二叉搜索树就是从小大按顺序，pre就是这个顺序中，当前pre的上一个，每次比较完pre就更新为当前的root，可以先看成一个一维数组去理解，再抽象成二叉搜索树。  
- 为什么pre放在外面而不是方法里面：因为放在外面才可以被递归的每一层访问到，里面的话就是局部变量，每一层都相互独立，就起不到一层的修改让另一层可见的作用了。  

## 今日博客分享  
  
[逐渐烧脑了起来，果然还是我太菜呜呜呜](https://zhuanlan.zhihu.com/p/589289168?) 很认真，思路很清晰，问题都总结得很透彻！