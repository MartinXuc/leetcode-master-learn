- **根据题目的数据量范围选择合适的算法**，比如数据量是10^5，那就只能使用 $O(n\log{n})$ 复杂度以下的算法了，使用 O(n^2) 是会超时的；而如果数据量只有 100 或者 1000 ，则可以果断的采用暴力方法（一般是 O(n^2) ）进行求解
- **为了特殊情况的专门写判断语句效用有多少？是否需要考虑特殊的情况？**
  - **需要考虑特殊情况**，比如容器/数组/指针是否为空等，可以在考虑到特殊情况后先额外判断写出来，整体逻辑写完后看是否能和一般情况进行合并。
- while复杂度分析主要看内部总共执行多少次，不是看跟 for 嵌套就成了 On2 ，滑动窗口就是 On。
- **涉及到修改字符串的 O(1) 算法理论上是只对字符串可以修改的编程语言成立的（如C++），对于其他编程语言通常参数会给成字符数组的形式**。
- 大家很多讨论都是讨论 bug ，发现大家还是很容易被 bug 卡住，推荐看一下上面给出的方法哈，找bug能力是非常非常重要的！！
- 对于常数级别复杂度的讨论：不需要纠结固定的什么数量级的复杂度，要从算法的整体复杂度上去考虑。开一千的空间，对于百万的数据量，它就是常数。但对于同样是几千甚至是几百的数据量，认为开这样一个空间是 O(1) 的复杂度从而认为是一个好的算法明显是不正确的。
- 大家力扣上建造用例的时候,对于树问题，可以尝试硬编码来进行构造数据哦如下图，还有就是利用力扣当中的 playground 来 cv 一下他们的工具，面试当中要求自己有建树操作，可以硬编码 or 力扣当中有给出 String->TreeNode 的方法。

![](assets/3.%20刷题小技巧/3.%20刷题小技巧.png)

- 几乎所有的代码问题都可以通过打日志调试来解决，哪里不懂打哪里的日志。

![](assets/3.%20刷题小技巧/3.%20刷题小技巧-1.png)

- **把力扣的代码放到本地ide调试的话要自己写主函数和一些数据结构，力扣给了一个函数我们填充好就行它后台会在main函数里进行调用放到本地就需要自己写main函数来进行调用啦。**
- JavaScript 版本的二叉树本地 debug 方式： https://blog.csdn.net/Maximus_ckp/article/details/125083775
- **回溯算法与 dfs 的区别:所有的回溯算法都可以说是深搜，所有的深搜都可以说是递归。那么回溯算法其实就是更具体的一个分类， 也就是父类和子类的一个关系。**
- 还是有同学没分清除浅拷贝和深拷贝:：**浅拷贝是操作同一个对象，深拷贝是复制一个一模一样的地址不一样的对象！！！牢记，add 要 new 一个新的。**
- 局部变量回溯，是隐含的回溯，全局变量的回溯是显示的回溯，对于什么题目该选择什么回溯方法，我建议能用全局就用全局，隐含回溯得创建销毁还麻烦，当然全局和局部大多数情况是可以互相转化的。
- 有的时候大家会发现 debug 并不能找到问题，这其实往往问题会出现在返回值和函数调用的过程，这种时候就只能拆分的粒度更细一点或者单独 test 一下函数调用。
- 递归的时候一般只需要考虑子问题，子问题处理没错一般就能默认处理完主问题。
- **有时候看到字符需要 - 'a' 'A'，数字需要 -'0' 主要是为了映射在数组上面, 不然都是 ascii 码映射就不准确了, 也无法定位。**