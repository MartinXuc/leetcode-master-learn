[toc]

## 目标

本规范的目标不是定义一个 C++ 特性的子集，也不是教大家如何使用现代 C++，而是希望通过这个规范，引导程序员编写风格统一的代码，减少常见编程错误，更加安全有效地使用 C++

- 对代码命名、排版、注释等风格方面做出约定
- 阻止过于复杂，不利于理解和维护的代码
- 避免因为定义行为、未指定行为导致的代码缺陷
- 避免因为粗心或误解而导致的编程错误

## 代码应该写成什么样子

程序必须为阅读它的人而编写，只是顺便用于机器执行。代码被读的次数远大于被修改的次数，遵循同一种风格带来的好处，远远超出为统一风格而付出的代价。

- 保持代码风格的统一
	- 项目组可以选择使用自己的风格，也可以选择使用规范建议的风格
	- 在项目组内应当实施一致的风格
- 保持代码简介
	- 整洁的代码更容易维护；
	- 短小的函数总是更简洁、容易阅读的；
	- 功能单一的函数更容易被复用。

## 避免未定义行为

拥有“未定义行为”的程序可以造成任意严重的后果。程序员必须不惜一切代价阻止“未定义行为”发生，且不能对“未定义行为”做任何假设。

**存在为定义行为的例子**：

- 整数除以 0
- 有符号整数运算溢出
- 引用空指针（对 nullptr 指向的内存进行读写操作）
- 越界访问数组
- 读取未初始化变量
- 访问已释放内存
- 使用 new T\[n\] 分配数组，但却不用带 \[\] 的 delete \[\] 来释放
- 数据竞争（data race），两个线程对同一个非原子变量，一个进行了写操作，另一个进行了读或写操作，而且这两个操作之间没有 happens-before 关系。

## 安全编码

**规范约束**：对所有外部数据进行合法性校验

## 与 C 编程规范的关系

- 代码风格上兼容 C；
- 编程实践上吸收大部分 C 规范，但是优先服务 C++ 特性与编程习惯

- 使用 C++ 提供的字符串库，代替 C 风格的字符串
- 使用 C++ 提供的 vector、array 等，代替原生数组
- 使用 C++ 提供的 iostream 等，代替 printf / scanf 等函数
- 使用 const / constexpr 常量，inline 函数、函数模板等代替宏
- 使用特殊成员函数或重载操作符替代 memset、memcpy、memcmp 等操作类对象
- 优先使用引用 / 智能指针代替原始指针
- ……