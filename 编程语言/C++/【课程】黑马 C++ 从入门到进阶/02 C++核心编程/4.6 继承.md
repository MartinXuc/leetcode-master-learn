### 4.6  继承

**继承是面向对象三大特性之一**

有些类与类之间存在特殊的关系，例如下图中：

![](./assets/4.6%20%E7%BB%A7%E6%89%BF.png)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码。



#### 4.6.1 继承的基本语法

例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同

接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处



**普通实现：**

```cpp
#include <iostream>
using namespace std;

//普通实现页面
```

```cpp
//Java 页面
class Java {
public:
	void header() {
		cout << "首页、公开课、登录、注册..（公共头部）" << endl;
	}
	void footer() {
		cout << "帮助中心、交流合作、站内地图..（公共底部）" << endl;
	}
	void left() {
		cout << "Java、Python、C++、..（公共分类列表）" << endl;
	}
	void content() {
		cout << "Java 学科视频" << endl;
	}
};

```

```cpp
//Python 页面
class Python {
public:
	void header() {
		cout << "首页、公开课、登录、注册..（公共头部）" << endl;
	}
	void footer() {
		cout << "帮助中心、交流合作、站内地图..（公共底部）" << endl;
	}
	void left() {
		cout << "Java、Python、C++、..（公共分类列表）" << endl;
	}
	void content() {
		cout << "Python 学科视频" << endl;
	}
};
```

```cpp
//C++页面
class CPP {
public:
	void header() {
		cout << "首页、公开课、登录、注册..（公共头部）" << endl;
	}
	void footer() {
		cout << "帮助中心、交流合作、站内地图..（公共底部）" << endl;
	}
	void left() {
		cout << "Java、Python、C++、..（公共分类列表）" << endl;
	}
	void content() {
		cout << "C++ 学科视频" << endl;
	}
};
```

```cpp
void test01() {
	cout << "Java 下载视频页面如下：" << endl;
	Java ja;
	ja.header();
	ja.footer();
	ja.left();
	ja.content();
	cout << "-----------------------------------------" << endl << endl;
}
```

```cpp
void test02() {
	cout << "Python 下载视频页面如下：" << endl;
	Python python;
	python.header();
	python.footer();
	python.left();
	python.content();
	cout << "-----------------------------------------" << endl << endl;
}

```

```cpp
void test03() {
	cout << "C++ 下载视频页面如下：" << endl;
	CPP cpp;
	cpp.header();
	cpp.footer();
	cpp.left();
	cpp.content();
	cout << "-----------------------------------------" << endl << endl;
}
```

```cpp
int main() {
	test01();
	test02();
	test03();
	return 0;
}
```



**继承实现：（仅展示类定义，其他部分代码相同）**

```cpp
//公共页面类
class BasePage {
public:
	void header() {
		cout << "首页、公开课、登录、注册..（公共头部）" << endl;
	}
	void footer() {
		cout << "帮助中心、交流合作、站内地图..（公共底部）" << endl;
	}
	void left() {
		cout << "Java、Python、C++、..（公共分类列表）" << endl;
	}
	void content() {
	}
};
```

```cpp
//Java 页面
class Java : public BasePage {
public:
	void content() {
		cout << "Java学科视频" << endl;
	}
};
//Python 页面
class Python : public BasePage {
public:
	void content() {
		cout << "Python学科视频" << endl;
	}
};
//C++ 页面
class CPP : public BasePage {
public:
	void content() {
		cout << "C++学科视频" << endl;
	}
};
```

**总结：**

继承的好处：==可以减少重复的代码==

格式：

```cpp
class 子类名 : 继承方式 父类;
```



**派生类中的成员，包含两大部分**：

一类是从基类继承过来的，一类是自己增加的成员。

从基类继承过过来的表现其共性，而新增的成员体现了其个性。



#### 4.6.2 继承方式

继承的语法：`class 子类 : 继承方式  父类`

**继承方式一共有三种：**

* 公共继承
* 保护继承
* 私有继承



![](./assets/4.6%20%E7%BB%A7%E6%89%BF-1.png)



**示例：**

```cpp
#include <iostream>
using namespace std;

//继承方式
//父类
class Base1 {
public:
	int m_A;//public
protected:
	int m_B;//protected
private:
	int m_C;//private
};
```

```cpp
//公共继承
class Son1 :public Base1 {
public:
	void func() {
		m_A = 10;//父类 public 子类 public
		m_B = 10;//父类 protected 子类 protected
		//m_C = 10;//父类 private 子类 不可访问
	}
};
void test01() {
	Son1 son1;
	son1.m_A = 100;//说明 m_A 在子类是 public
	//son1.m_B = 100;//protected 不可访问
	//son1.m_C = 100;//不可访问
}
```

```cpp
//保护继承
class Son2 :protected Base1 {
	void func() {
		m_A = 10;//父类 public 子类 protected
		m_B = 10;//父类 protected 子类 protected
		//m_C = 10;//父类 private 子类 不可访问
	}
};
void test02() {
	Son2 son2;
	//son2.m_A = 100;//protected 不可访问
	//son2.m_B = 100;//protected 不可访问
	//son2.m_C = 100;//不可访问
}
```

```cpp
//私有继承
class Son3 :private Base1 {
	void func() {
		m_A = 10;//父类 public 子类 private
		m_B = 10;//父类 protected 子类 private
		//m_C = 10;//父类 private 子类 不可访问
	}
};
void test02() {
	Son2 son2;
	//son2.m_A = 100;//private 不可访问
	//son2.m_B = 100;//private 不可访问
	//son2.m_C = 100;//不可访问
}
```

```cpp
int main() {
	return 0;
}
```



#### 4.6.3 继承中的对象模型

**问题：**从父类继承过来的成员，哪些属于子类对象中？

答案：全都是。

**示例：**

```C++
class Base
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C; //私有成员只是被隐藏了，但是还是会继承下去
};

//公共继承
class Son :public Base
{
public:
	int m_D;
};

void test01()
{
	cout << "sizeof Son = " << sizeof(Son) << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```



利用工具查看：

![](./assets/4.6%20%E7%BB%A7%E6%89%BF-2.png)

打开工具窗口后，定位到当前CPP文件的盘符

然后输入： `cl /d1 reportSingleClassLayout` 查看的类名所属文件名

效果如下图：

![](./assets/4.6%20%E7%BB%A7%E6%89%BF-3.png)

> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到



#### 4.6.4 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

**问题：** 父类和子类的构造和析构顺序是谁先谁后？

**示例：**

```cpp
#include <iostream>
using namespace std;

//继承中的构造和析构函数的顺序
```

```cpp
class Base {
public:
	Base() {
		cout << "Base 构造" << endl;
	}
	~Base() {
		cout << "Base 析构" << endl;
	}
};
```

```cpp
class Son : public Base {
public:
	Son() {
		cout << "Son 构造" << endl;
	}
	~Son() {
		cout << "Son 析构" << endl;
	}
};
```

```cpp
void test01() {
	Son son;
}

int main() {
	test01();
	return 0;
}
```

结果：

> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反。符合栈的特性。



#### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

* 访问子类同名成员   直接访问即可
* 访问父类同名成员   需要 **加作用域**

**示例：**

```cpp
#include <iostream>
using namespace std;

//继承中同名函数处理
```

```cpp
class Base {
public:
    Base(){
        m_A = 100;
    }
    void func(){
        cout << "Base func()" << endl;
    }
    int m_A;
};
class Son :public Base {
public:
    Son(){
        m_A = 200;
    }
    void func(){
        //重名函数
        cout << "Son func()" << endl;
    }
    int m_A;//重名变量
};
```

```cpp
void test01(){
    //同名成员变量
    Son s;
    cout << s.m_A << endl; //200
    cout << s.Base::m_A << endl; //100
}
void test02(){
    //同名成员函数
    Son s;
    s.func();//Son func()
    s.Base::func();//Base func()
}
int main() {
    test01();
    test02();
    return 0;
}
```

总结：

1. 子类对象可以直接访问到子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数
4. 若父类中有函数重载，且这个函数列表子类没有，直接访问它按理说应该没有歧义，但是依然需要添加父类作用域。



#### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员   直接访问即可
- 访问父类同名成员   需要加作用域

**示例：**

```cpp
#include <iostream>
using namespace std;

//继承中同名静态成员处理方式
```

```cpp
class Base {
public:
    static int m_A;
    static void func(){
        cout << "Base -- static void func()" << endl;
    }
};
int Base::m_A = 100;
```

```cpp
class Son : public Base {
public:
    static int m_A;
    static void func(){
        cout << "Son -- static void func()" << endl;
    }
};
int Son::m_A = 200;
```

```cpp
//同名静态成员属性
void test01(){
    cout << "通过对象访问" << endl;
    Son s;
    cout << "Son 里的 m_A = " << s.m_A << endl; // 200
    cout << "Base 里的 m_A = " << s.Base::m_A << endl; //100

    cout << "通过类名访问" << endl;
    cout << "Son 里的 m_A = " << Son::m_A << endl; // 200
    cout << "Base 里的 m_A = " << Son::Base::m_A << endl; //100
}
```

```cpp
//同名静态成员函数
void test02(){
    Son s;
    cout << "通过对象访问" << endl;
    s.func();
    s.Base::func();
    cout << "通过类名访问" << endl;
    Son::func();
    Son::Base::func();
}
```

```cpp
int main() {
    test01();
    return 0;
}
```

> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）



#### 4.6.7 多继承语法



C++允许 **一个类继承多个类**

语法：` class 子类 : 继承方式 父类1, 继承方式 父类2...`

多继承可能会引发父类中有同名成员出现，需要加作用域区分

**C++实际开发中不建议用多继承**

**示例：**

```cpp
#include <iostream>
using namespace std;

//多继承语法

class Base1{
public:
    int m_A;
    Base1():m_A(100){}
};
class Base2{
public:
    int m_A;
    Base2():m_A(200){}
};
```

```cpp
//子类：需要继承 Base1 和 Base2
//语法：class 子类，继承方式 父类1，继承方式 父类2, ... （如果还有可以继续加）
class Son:public Base1, public Base2{
public:
    int m_C;
    int m_D;
    Son():m_C(300), m_D(400){}
};
```

```cpp
void test01(){
    Son s;
    //一共有四个int 类型的变量
    cout << "sizeof son = " << sizeof(s) << endl; //16
    //同名对象加作用域
    cout << s.Base1::m_A << endl;
    cout << s.Base2::m_A << endl;
}

```

```cpp
int main() {
    test01();
    return 0;
}
```



> 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域



#### 4.6.8 菱形继承

**菱形继承概念：**

​	两个派生类继承同一个基类

​	又有某个类同时继承者两个派生类

​	这种继承被称为菱形继承，或者钻石继承

**典型的菱形继承案例：**

![](./assets/4.6%20%E7%BB%A7%E6%89%BF.jpg)

**菱形继承问题：**

1.   羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
2.   草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。



**示例：**

```cpp
#include <iostream>
using namespace std;
//菱形继承的两个问题及解决
```

```cpp
//动物类
class Animal{
public:
    int m_Age;//羊驼类里显然会出现同名问题，需要加作用域来区分
};
//羊类
class Sheep:virtual public Animal{};
//驼类
class Tuo:virtual public Animal{};
//羊驼类
class SheepTuo:public Sheep, public Tuo{};
```

```cpp
void test01(){
    SheepTuo st;
    //菱形继承时，两个父类拥有相同数据
    //使用作用域来解决这个问题
    st.Sheep::m_Age = 18;
    st.Sheep::m_Age = 28;
    cout << "st.Sheep::m_Age = " << st.Sheep::m_Age << endl;
    cout << "st.Tuo::m_Age = " << st.Tuo::m_Age << endl;

    //但是这份数据我们知道只要有一份就可以，菱形继承导致数据有两份，资源浪费
    //使用虚继承来解决这一问题
    //在继承之前加上关键字 virtual 变为虚继承
    //如本例，Animal类称为虚基类
    //这样子，就不需要使用作用域了，没有二义性的问题，但是加上仍然不会有错误
    //虚继承继承的成员变量是一个 vbptr 指针，指向 vbtable，这个表中记录了虚基类的地址
}

int main() {
    test01();
    return 0;
}
```

总结：

* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
* 利用虚继承可以解决菱形继承问题
* 不推荐使用菱形继承