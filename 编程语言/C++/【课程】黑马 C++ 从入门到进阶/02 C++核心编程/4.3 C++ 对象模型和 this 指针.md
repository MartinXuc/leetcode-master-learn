### 4.3 C++对象模型和this指针

#### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储。

**只有** **非静态成员变量** 才属于类的**对象**上。

空对象的大小为1，需要占一个位。

```C++
#include <iostream>
using namespace std;

//成员变量 和 成员函数 是分开存储的
```

```cpp
class Person {};

class PersonNotNULL {
public:
	int m_A;//非静态成员变量
	static int m_B;//静态成员变量，不占实例化后对象的内存空间
	void func() {}//非静态成员函数，不占实例化后对象的内存空间
	static void funcStatic() {}//静态成员函数，也不占实例化后对象的内存空间
};
```

```cpp
void test01() {
	Person p;
	//空对象占用内存空间为：1
	//C++ 编译器会给每个空对象分配 1 个字节的空间，主要是用来占位
	//每个空对象也都有一个独一无二的内存地址
	cout << "sizeof p = " << sizeof(p) << endl;
}
```

```cpp
void test02() {
	PersonNotNULL p;
	//非空对象占用内存空间就是成员实际大小
	//此处输出应为 4
	cout << "sizeof p = " << sizeof(p) << endl;
}
```

```cpp
int main() {
	test02();
	return 0;
}
```



#### 4.3.2 this指针概念

通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的。

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是 **隐含** 每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针的用途：

*  当形参和成员变量**同名**时，可用this指针来区分
    * 但是更推荐使用 `m_变量名` 的方式来避免重名。
*  在类的非静态成员函数中返回对象本身，可使用 `return *this`

```C++
#include <iostream>
using namespace std;
```

```cpp
class Person {
public:
	Person(int age) {
		//age = age; 这样是错误的
		this->age = age;
	}
	Person& PersonAddAge(Person& p) {
		this->age += p.age;
		return *this;
	}
	int age;
};
```

```cpp
// this 的作用
//1、解决名称冲突
void test01() {
	Person p1(18);
	cout << "p1 的年龄为：" << p1.age << "岁\n";
}
```

```cpp
//2、返回对象本身用 *this
void test02() {
	Person p1(10);
	Person p2(10);
	//链式编程思想，需要函数返回对象引用，使用 return *this
	//cout << << <<就是一个典型的链式编程应用
	p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);
	cout << "p2 的年龄为：" << p2.age << "岁\n";
}
```

```cpp
int main() {
	test01();
	test02();
	return 0;
}
```

#### 4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针，空指针不存在对应的 this 指针，因而成员函数涉及 this 指针的时候，会报错。

如果用到this指针，需要加以判断保证代码的健壮性

**示例：**

```C++
#include <iostream>
using namespace std;

//空指针调用成员函数

class Person {
public:
	void showClassName() {
		cout << "this is Person class" << endl;
	}
	void showPersonAge() {
		cout << "age = " << m_Age << endl;
	}
	int m_Age;
};

void test01() {
	Person* p = NULL;
	p->showClassName();//正常调用，不会出错
	//p->showPersonAge();//本行代码无法执行，因为函数里用到了一个对象的成员变量，而空指针没有对应的对象。
}

int main() {
	return 0;
}
```

为了保证健壮性，可以把 `showPersonAge()` 函数加一个判断：

```cpp
void showPersonAge() {
	if (this == nullptr) {
		return;
	}
	cout << "age = " << m_Age << endl;
}
```


#### 4.3.4 const修饰成员函数

**常函数：**

* 成员函数后加const后我们称为这个函数为**常函数**
* 常函数内不可以修改成员属性
    * 原理：常函数的 const 相当于加到了 this 指针前面，让 this 指向的对象不允许修改。
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象：**

* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数

**示例：**

```C++
#include <iostream>
using namespace std;

class Person {
public:
	//this 指针的本质是指针常量，指针的指向是不可以修改的
	//成员函数再加一个 const，修饰的是 this 指针
	//形成了 “常量指针常量”，指针指向的对象也不可以修改了
	void func() const {
		//m_A = 100; //显然这里是不允许修改了
		m_B = 100; //允许修改
	}
	void funcNotConst() {}
	int m_A;
	mutable int m_B;//特殊变量，即使在常函数中，也可以修改这个值
};

void test01() {
	Person p;
	p.func();
}

void test02() {
	const Person p; //常对象
	//p.m_A = 100; //报错，不允许修改
	p.m_B = 100; //mutable 变量允许修改

	//还有一个限制就是常对象只能调用常函数
	//p.funcNotConst(); //不允许调用，即使就是一个空函数
}
int main() {
	return 0;
}
```

