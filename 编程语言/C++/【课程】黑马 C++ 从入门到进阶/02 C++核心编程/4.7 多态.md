### 4.7  多态

#### 4.7.1 多态的基本概念

**多态是C++面向对象三大特性之一**

多态分为两类

-   静态多态：函数重载 和 运算符重载属于静态多态，复用函数名。（前面已经学过）
-   动态多态：派生类和虚函数实现运行时多态。

静态多态和动态多态区别

-   静态多态的函数地址早绑定  -  编译阶段确定函数地址（编译时多态）
-   动态多态的函数地址晚绑定  -  运行阶段确定函数地址（运行时多态）

下面通过案例进行讲解多态

```cpp
#include <iostream>
using namespace std;

//多态

//动物类
class Animal{
public:
    // void speak(){
    //     cout << "动物在说话" << endl;
    // }
    virtual void speak(){
        cout << "动物在说话" << endl;
    }
};
```

```cpp
class Cat: public Animal{
public:
    void speak(){
        cout << "小猫在说话" << endl;
    }
};
class Dog: public Animal{
public:
    void speak(){
        cout << "小狗在说话" << endl;
    }
};
```

```cpp
//执行说话的函数
//地址早绑定，在编译阶段就确定函数地址
//如果想让猫说话，这个函数的地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定
//只需要在 Animal 类中的 speak 函数前加上 virtual
void doSpeak(Animal& animal){ //父类引用接受子类对象： Animal& animal = cat;
    animal.speak();
}

void test01(){
    Cat cat;
    doSpeak(cat);
    Dog dog;
    doSpeak(dog);
}

//动态多态满足条件
//1.有继承关系
//2.子类重写父类的虚函数
//多态使用条件
//父类指针或引用指向子类对象

```

```cpp
int main(){
    test01();
    return 0;
}
```

总结：

多态满足条件

-   有继承关系
-   子类重写父类中的虚函数

多态使用条件

-   父类指针或引用指向子类对象

重写：函数返回值类型  函数名 参数列表 完全一致称为重写



#### 4.7.2 多态案例一-计算器类

**案例描述：**

分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类

**多态的优点：**

-   代码组织结构清晰
-   可读性强
-   利于前期和后期的扩展以及维护

**示例：**

```cpp
#include <iostream>
#include <string>
using namespace std;

//分别利用普通写法和多态技术实现计算器
```

```cpp
//普通写法
class Calculator {
public:
	int getResult(string oper);
	int m_Num1; //操作数1
	int m_Num2; //操作数2
};
int Calculator::getResult(string oper) {
	if (oper == "+") {
		return m_Num1 + m_Num2;
	}
	else if (oper == "-") {
		return m_Num1 - m_Num2;
	}
	else if (oper == "*") {
		return m_Num1 * m_Num2;
	}
	else return -1;
	//如果想要扩展新的功能，需要修改源码
	//真实开发中，提倡开闭原则
	//开闭原则：对扩展进行开放，对修改进行关闭
}
```

```cpp
void test01() {
	//创建计算器对象
	Calculator c;
	c.m_Num1 = 10;
	c.m_Num2 = 10;
	cout << c.m_Num1 << "+" << c.m_Num2 << "=" << c.getResult("+") << endl;
	cout << c.m_Num1 << "-" << c.m_Num2 << "=" << c.getResult("-") << endl;
	cout << c.m_Num1 << "*" << c.m_Num2 << "=" << c.getResult("*") << endl;
}
```

```cpp
//利用多态实现计算器类
//计算器抽象类
//多态好处：
//1、组织结构清晰
//2、可读性强
//3、对于前期和后期的扩展与维护性高

class AbstractCalculator {
public:
	virtual int getResult() { return 0; }
	int m_Num1;
	int m_Num2;
};
//加法计算器类
class AddCalculator :public AbstractCalculator {
public:
	int getResult() {
		return m_Num1 + m_Num2;
	}
};
//减法计算器类
class SubCalculator :public AbstractCalculator {
public:
	int getResult() {
		return m_Num1 - m_Num2;
	}
};
//乘法计算器类
class MulCalculator :public AbstractCalculator {
public:
	int getResult() {
		return m_Num1 * m_Num2;
	}
};
```

```cpp
void test02() {
	cout << endl;
	//多态使用条件：父类指针指向子类对象
	//加法运算
	AbstractCalculator* p = new AddCalculator;
	p->m_Num1 = 10;
	p->m_Num2 = 10;
	cout << p->m_Num1 << "+" << p->m_Num2 << "=" << p->getResult() << endl;
	//手动销毁
	delete p;
	//减法运算
	p = new SubCalculator;
	p->m_Num1 = 10;
	p->m_Num2 = 10;
	cout << p->m_Num1 << "-" << p->m_Num2 << "=" << p->getResult() << endl;
	//手动销毁
	delete p;
	//乘法运算
	p = new MulCalculator;
	p->m_Num1 = 10;
	p->m_Num2 = 10;
	cout << p->m_Num1 << "*" << p->m_Num2 << "=" << p->getResult() << endl;
	//手动销毁
	delete p;
}
int main() {
	test01();
	test02();
	return 0;
}
```

>   总结：C++开发提倡利用多态设计程序架构，因为多态优点很多




#### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为**纯虚函数**。

纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`

当类中有了纯虚函数，这个类也称为 **抽象类**

**抽象类特点**：

-   无法实例化对象
-   子类必须重写抽象类中的纯虚函数，否则也属于抽象类

**示例：**

```cpp
#include <iostream>
using namespace std;

//纯虚函数和抽象类
class Base {
public:
	//纯虚函数
	//只要有一个纯虚函数，这个类称为抽象类
	//抽象类特点：
	//1、无法实例化对象
	//2、抽象类的子类必须要重写父类中的纯虚函数，否则子类仍然是抽象类
	virtual void func() = 0;
};
class Son1 :public Base {
public:
};
class Son2 :public Base {
public:
	void func() { cout << "Function函数的调用" << endl; }
};
```

```cpp
void test01() {
	//Base b;	//抽象类无法实例化对象 -- 栈区
	//Base* p = new Base;	//抽象类无法实例化对象 -- 堆区
	//Son1 s1;	//子类未重写纯虚函数，还是抽象类，不可以实例化对象
	Base* base = new Son2;
	base->func();
}

int main() {
	test01();
	return 0;
}
```



#### 4.7.4 多态案例二-制作饮品

**案例描述：**

制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料

利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶

![](./assets/4.7%20%E5%A4%9A%E6%80%81.png)

**示例：**

```cpp
#include <iostream>
using namespace std;

//多态案例2 制作饮品
//先写抽象类
class AbstractDrinking {
public:
	//煮水
	virtual void Boil() = 0;
	//冲泡
	virtual void Brew() = 0;
	//倒入杯中
	virtual void PourInCup() = 0;
	//加入辅助佐料
	virtual void PutSomething() = 0;
	//制作饮品
	void makeDrink() {
		Boil();
		Brew();
		PourInCup();
		PutSomething();
	}
};
```

```cpp
//制作咖啡
class Coffee :public AbstractDrinking {
public:
	//煮水
	virtual void Boil() { cout << "煮农夫山泉" << endl; }
	//冲泡
	virtual void Brew() { cout << "冲泡咖啡" << endl; }
	//倒入杯中
	virtual void PourInCup() { cout << "倒入咖啡杯" << endl; }
	//加入辅助佐料
	virtual void PutSomething() { cout << "加入糖和牛奶" << endl; }
};
//制作茶叶
class Tea :public AbstractDrinking {
public:
	//煮水
	virtual void Boil() { cout << "煮矿泉水" << endl; }
	//冲泡
	virtual void Brew() { cout << "冲泡茶叶" << endl; }
	//倒入杯中
	virtual void PourInCup() { cout << "倒入茶杯" << endl; }
	//加入辅助佐料
	virtual void PutSomething() { cout << "辅料啥也不加" << endl; }
};
```

```cpp
void doWork(AbstractDrinking* abs) {
	abs->makeDrink();
	delete abs;
}
void test01() {
	//制作咖啡
	doWork(new Coffee);
	cout << endl;
	//制作茶
	doWork(new Tea);
}

int main() {
	test01();
	return 0;
}
```



#### 4.7.5 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。

解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**

虚析构和纯虚析构共性：

-   可以解决父类指针释放子类对象
-   都需要有具体的函数实现

虚析构和纯虚析构区别：

-   如果是 **纯** 虚析构，该类属于抽象类，无法实例化对象



虚析构语法：

```cpp
virtual ~类名(){}
```

纯虚析构语法：

```cpp
virtual ~类名() = 0;
类名::~类名(){}//纯虚析构必须要写实现
```



**示例：**

```cpp
#include <iostream>
#include <string>
using namespace std;
//虚析构与纯虚析构
class Animal {
public:
	//纯虚函数
	virtual void speak() = 0;
	Animal() { cout << "Animal 构造函数调用" << endl; }
	//父类析构函数需要声明为虚函数，从而可以让父类指针可以调用子类对象的析构函数
	//virtual ~Animal() { cout << "Animal 析构函数调用" << endl; }
	//纯虚析构
	virtual ~Animal() = 0;
};
Animal::~Animal() {
	//必须要有这样的一个实现，析构函数不允许只声明，否则无法链接
	//纯虚函数就不需要，这里是不同的
	cout << "Animal 纯虚析构函数调用" << endl;
}
```

```cpp
class Cat :public Animal {
public:
	void speak() {
		cout << *m_Name << "小猫在说话" << endl;
	}
	Cat(string name) {
		cout << "Cat 构造函数调用" << endl;
		m_Name = new string(name);
	}
	~Cat() {
		if (m_Name != nullptr) {
			cout << "Cat 析构函数调用" << endl;
			delete m_Name;
			m_Name = NULL;
		}
	}
	string* m_Name;
};
```

```cpp
void test01() {
	Animal* animal = new Cat("Tom");
	animal->speak();
	delete animal;
}
int main() {
	test01();
	return 0;
}
```

总结：

1.   虚析构或纯虚析构就是用来解决**通过父类指针释放子类对象**
2.   如果子类中**没有堆区数据，可以不写**为虚析构或纯虚析构
3.   拥有纯虚析构函数的类也属于抽象类



#### 4.7.6 多态案例三-电脑组装

**案例描述：**

电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）

将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商

创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口

测试时组装三台不同的电脑进行工作

**设计：**

```cpp
//抽象出每个零件的类
class CPU 抽象类 {
    //抽象计算函数
    virtual void calculate() = 0;
};

class VideoCard 抽象类 {
    //抽象显示函数
    virtual void display() = 0;
}

class Memory 抽象类 {
    //抽象存储函数
    virtual void storage() = 0;
}

//电脑类
class Computer{
    //构造函数中传入 3 个零件指针
    //提供一个工作函数调用每个零件的工作接口
}

//具体零件厂商
//Intel
class IntelCPU :public CPU {
    void calculate() {
        cout << "Intel的CPU开始计算了！" <<endl;
    }
}
//其他厂商……
//测试阶段 组装三台不同的电脑
```



**示例：**

```c++
#include <iostream>
using namespace std;
//抽象类
class CPU {
public:
	virtual void calculate() = 0;
};
class GPU {
public:
	virtual void display() = 0;
};
class Memory {
public:
	virtual void storage() = 0;
};
```

```cpp
//电脑类
class Computer {
public:
	//构造函数中传入 3 个零件指针
	Computer(CPU* cpu, GPU* gpu, Memory* memory) {
		m_Cpu = cpu;
		m_Gpu = gpu;
		m_Memory = memory;
	}
	void work() {
		m_Cpu->calculate();
		m_Gpu->display();
		m_Memory->storage();
	}
	~Computer() {
		if (m_Cpu != nullptr) {
			delete m_Cpu;
			m_Cpu = nullptr;
		}
		if (m_Gpu != nullptr) {
			delete m_Gpu;
			m_Gpu = nullptr;
		}
		if (m_Memory != nullptr) {
			delete m_Memory;
			m_Memory = nullptr;
		}
	}
private:
	CPU* m_Cpu;
	GPU* m_Gpu;
	Memory* m_Memory;
};
```

```cpp
//各种零件子类
class IntelCPU :public CPU {
	void calculate() {
		cout << "Intel CPU 在计算" << endl;
	}
};
class AMDCPU :public CPU {
	void calculate() {
		cout << "AMD CPU 在计算" << endl;
	}
};
class NvdiaGPU :public GPU {
	void display() {
		cout << "Nvida GPU 在输出画面" << endl;
	}
};
class AMDGPU :public GPU {
	void display() {
		cout << "AMD GPU 在输出画面" << endl;
	}
};
class SUMSUNGMemory :public Memory {
	void storage() {
		cout << "三星内存在工作中" << endl;
	}
};
class KingstonMemory :public Memory {
	void storage() {
		cout << "金士顿内存在工作中" << endl;
	}
};
```

```cpp
void test01() {
	//组装第 1 台电脑让它工作
	//A + A + S
	cout << "装第 1 台电脑，测试中：\n";
	Computer* computer1 = new Computer(new AMDCPU, new AMDGPU, new SUMSUNGMemory);
	computer1->work();
	cout << endl;

	//组装第 2 台电脑让它工作
	//A + N + S
	cout << "装第 2 台电脑，测试中：\n";
	Computer* computer2 = new Computer(new AMDCPU, new NvdiaGPU, new SUMSUNGMemory);
	computer2->work();
	cout << endl;

	//组装第 3 台电脑让它工作
	//A + A + K
	cout << "装第 3 台电脑，测试中：\n";
	Computer* computer3 = new Computer(new AMDCPU, new AMDGPU, new KingstonMemory);
	computer3->work();
	cout << endl;
}
int main() {
	test01();
	return 0;
}
```

**结果：**

![](./assets/4.7%20%E5%A4%9A%E6%80%81-1.png)

