[toc]

# 代码随想录算法训练营 第 1 天 ｜ 数组理论基础，二分查找，移除元素，有序数组的平方

## 数组理论基础

1. 数组是连续空间
2. 数组增删元素复杂度比较高
3. 数组支持随机访问
4. 二维数组的地址空间不一定是连续的，与编程语言实现有关
5. Python 的 list 就是一个动态数组，特性与上面的描述一致
6. C++ 的 vector 也是一个动态数组，特性与上面的描述一致
7. C++ 的数组是静态数组，创建变量之后长度即固定

## 二分查找

- [力扣题目链接](https://leetcode.cn/problems/binary-search/)
- [代码随想录](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

二分查找主要看对边界条件的把控。个人习惯使用左闭右闭的方式。

需要设置一个 `left` 指针和一个 `right` 指针，然后计算中间指针 `mid`，通常是取 `left` 和 `right` 的平均数，根据 `target` 和 `nums[mid]` 的大小关系，更新 `left` 和 `right` 的值。

更新 `left` 和 `right` 的值时，需要考虑 `left` 和 `right` 的更新方式。

- 如果 `target` 大于 `nums[mid]`，则 `left` 更新为 `mid + 1`
- 如果 `target` 小于 `nums[mid]`，则 `right` 更新为 `mid - 1`
- 如果 `target` 等于 `nums[mid]`，则返回 `mid`

### 代码实现

```python
# python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > target:
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                return mid
        return -1
```

```cpp
// cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        int mid;
        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            }
            else if (nums[mid] < target) {
                left = mid + 1;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
};
```

## 移除元素

- [力扣题目链接](https://leetcode.cn/problems/remove-element/)
- [代码随想录](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

可以使用双指针进行，一个快指针用来遍历数组，另一个慢指针用来作为新数组的结尾，如果遍历到的数字是要删除的数字，那么就直接跳过，如果不是要删除的数字，那么就赋值给慢指针，然后慢指针加一。

然后规定慢指针的初始值为 -1，每次先+1，然后赋值给慢指针；规定快指针初始值为 0，表示当前遍历到的数字。

### 代码实现

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast = 0
        slow = -1
        while fast < len(nums):
            if nums[fast] != val:
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return slow + 1
```

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int fast = 0;
        int slow = -1;
        while (fast < nums.size()) {
            if (nums[fast] != val) {
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        return slow + 1;
    }
};
```

## 有序数组的平方

- [力扣题目链接](https://leetcode.cn/problems/squares-of-a-sorted-array/)
- [代码随想录链接](https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html)

### 实现思路

1. 暴力思路：全部平方，然后排序
2. 优化思路：头尾设置各设置一个指针，然后每次将绝对值小的数字平方之后移动到一个新数组中。

### 代码实现

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        head = 0
        tail = len(nums) - 1
        ans = list()
        while head <= tail:
            if abs(nums[head]) > abs(nums[tail]):
                ans.append(nums[head] ** 2)
                head += 1
            else:
                ans.append(nums[tail] ** 2)
                tail -= 1
        return ans[::-1]
```

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int head = 0;
        int tail = nums.size() - 1;
        vector<int> ans;
        while (head <= tail) {
            if (abs(nums[head]) < abs(nums[tail])) {
                ans.push_back(nums[tail] * nums[tail]);
                tail--;
            }
            else {
                ans.push_back(nums[head] * nums[head]);
                head++;
            }
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

### 额外收获

- 对于反转一个数组，Python 可以直接使用切片操作 `[::-1]`，而 C++ 可以使用 `std::reverse(begin,end)`。

## 今日总结

没遇到什么困难，希望可以把题目安安稳稳刷下去，加油。