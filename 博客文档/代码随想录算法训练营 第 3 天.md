[toc]

# 代码随想录算法训练营 第 3 天 | 链表理论基础、移除链表元素、设计链表、反转链表

## 链表理论基础

- 链表的节点在内存中是离散分布的，通过指针连接
- 链表的基本定义：

```cpp
struct ListNode {
    int val;
    ListNode *Next;
    ListNode(int x): val(x), next(NULL) {}
};
```

- 链表插入和删除的复杂度都是 O(1)，这是链表自身的优势，但是查询复杂度是 O(n)，这是链表的劣势。

## 移除链表元素

- [题目链接](https://leetcode.cn/problems/remove-linked-list-elements/)
- [代码随想录链接](https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

遍历一遍删除即可，是一个基本的链表练习题目。

### 代码实现

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        # 创建虚拟头节点，统一删除操作
        virtual_head = ListNode(0, head)
        p = virtual_head
        while p.next is not None:
            if p.next.val == val:
                p.next = p.next.next
            else:
                p = p.next
        return virtual_head.next
```

### 看录后想法

讲了带头节点和不带头节点的写法，感觉意料之中。还有一个递归的写法，感觉怪怪的，像是为了递归而递归，太不直观了。

### 小结

没什么好说的。

## 设计链表

- [题目链接](https://leetcode.cn/problems/design-linked-list/)
- [代码随想录链接](https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html)

### 题目思路

把想到的写出来就可以，但是要注意边界条件。

### 代码实现

```python
class LinkNode:
    def __init__(self, val = 0, next = None):
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        self.head = LinkNode(0, None)

    def get(self, index: int) -> int:
        p = self.head
        for _ in range(index):
            p = p.next
        if p is None or p.next is None:
            return -1
        return p.next.val

    def addAtHead(self, val: int) -> None:
        p = LinkNode(val, self.head.next)
        self.head.next = p

    def addAtTail(self, val: int) -> None:
        p = self.head
        while p.next is not None:
            p = p.next
        temp = LinkNode(val)
        p.next = temp

    def addAtIndex(self, index: int, val: int) -> None:
        p = self.head
        for _ in range(index):
            if p is None:
                return
            p = p.next
        if p is None:
            p = LinkNode(val)
            return
        temp = LinkNode(val, p.next)
        p.next = temp


    def deleteAtIndex(self, index: int) -> None:
        p = self.head
        for _ in range(index):
            p = p.next
        if p is None or p.next is None:
            return
        p.next = p.next.next
        


# Your MyLinkedList object will be instantiated and called as such:
# obj = MyLinkedList()
# param_1 = obj.get(index)
# obj.addAtHead(val)
# obj.addAtTail(val)
# obj.addAtIndex(index,val)
# obj.deleteAtIndex(index)
```

### 看录后想法

没什么想法。

### 小结

无。

## 反转链表

- [题目链接](https://leetcode.cn/problems/reverse-linked-list/)
- [代码随想录链接](https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

正常凭着直觉往下写就行了。

### 代码实现

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 先处理特殊情况(链表长度不足3)
        if head is None:
            return head
        elif head.next is None:
            return head
        elif head.next.next is None:
            temp = head.next
            temp.next = head
            head.next = None
            return temp
        # 经过分析，设置 3 个指针来进行操作是比较简单直观的
        pre = head
        cur = pre.next
        nxt = cur.next
        pre.next = None
        # 设置循环条件
        while nxt is not None:
            cur.next = pre
            pre = cur
            cur = nxt
            nxt = nxt.next
        cur.next = pre
        return cur
```

### 看录后想法

还有递归写法，后面有空了可以看看。

### 小结

无。