[toc]

# 代码随想录算法训练营 第 2 天 | 长度最小的子数组、螺旋矩阵II、区间和、开发商购买土地、数组总结篇

## 长度最小的子数组

- [力扣题目链接](https://leetcode.cn/problems/minimum-size-subarray-sum/)
- [随想录链接](https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

首先想到就是一个滑动窗口了，窗口由快指针和慢指针划出闭区间的范围，然后维护一个区间和的变量。当区间和不足目标值，就继续快指针往前跑，当区间和大于目标值，那就让慢指针往前跑。因为要返回的是最小的区间长度，那只需要设置一个变量用来记录最小长度即可。

### 代码实现

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        # 设置滑动窗口的边界，使用闭区间
        left = 0
        right = -1
        cur_len= 0
        sum = 0
        min_len = len(nums)
        min_exist= False
        
        # 开始滑动
        while left < len(nums):
            if sum < target:
                right += 1
                if right == len(nums):
                    break
                cur_len += 1
                sum += nums[right]
            else:
                min_len = cur_len if cur_len < min_len else min_len
                sum -= nums[left]
                left += 1
                cur_len -= 1
                min_exist = True
        if min_exist:
            return min_len
        else:
            return 0
```

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        // 设置滑动窗口边界，使用闭区间
        int left = 0, right = -1;
        int curSize = 0;
        int minSize = nums.size();
        int sumOfWindow = 0;
        bool found = false;
        while (left < nums.size()) {
            if (sumOfWindow < target) {
                if (right == nums.size() - 1) {
                    break;
                }
                ++right;
                ++curSize;
                sumOfWindow += nums[right];
            }
            else {
                found = true;
                minSize = minSize < curSize ? minSize : curSize;
                sumOfWindow -= nums[left];
                ++left;
                --curSize;
            }
        }
        if (found) return minSize;
        else return 0;
    }
};
```

### 看录感想

思路上其实是一致的，但是具体实现上，出现了一定的分别。我个人更习惯直接写一个 while，然后左右两个指针在里面根据条件移动，而录里的代码更多的是先看准一个指针的移动，然后观察另一个指针的移动。我暂时看不出哪一个更优秀。

## 螺旋矩阵II

- [力扣题目链接](https://leetcode.cn/problems/spiral-matrix-ii/)
- [代码随想录链接](https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

首先想到的就是模拟的思路，暂时也想不出什么别的思路，猜测本题就是考察对代码的掌握程度。

经过观察，每次写完 2 条边之后，剩下的就又是一个完整的正方形，可以写成递归。不过发现这个思路下来每次写矩阵的方向是不一样的，不好统一。不过如果每次画 4 条边，则一样可以递归，而且可以做到每一层的操作是统一的。

关键点在于画出 4 条边的函数实现，定义函数：`drawEdge(const int x, const int y, const int n, int & num, vector<vector<int>>& nums)`，参数说明：

- `x,y` 起始坐标，表明下一次需要写下的位置
- `n` 正方形边长
- `num` 起始数据，表明下一次需要写下的数字
- `nums` 待操作的数组

写到这里发现可以不用递归，循环即可

### 代码实现

```python
class Solution:
    def draw_edge(self, x: int, y: int, n: int, num: int, nums: List[List[int]])-> int:
        i, j = y, x
        for j in range(x, x + n):
            nums[i][j] = num
            num += 1
        for i in range(y + 1, y + n):
            nums[i][j] = num
            num += 1
        for j in range(x + n - 2, x - 1, -1):
            nums[i][j] = num
            num += 1 
        for i in range(y + n - 2, y, -1):
            nums[i][j] = num
            num += 1
        return num

    def generateMatrix(self, n: int) -> List[List[int]]:
        nums = [[0] * n for _ in range(n)]
        x = y = 0
        num = 1
        while True:
            num = self.draw_edge(x, y, n, num, nums)
            x = y = x + 1
            n -= 2
            if n <= 0:
                break
        return nums
```

```cpp
class Solution {
public:
    void drawEdge(const int x, const int y, const int n, int & num, vector<vector<int>>& nums) {
        int i = y, j = x;
        for (; j < x + n; j++, num++) {
            nums[i][j] = num;
            // cout << "i = " << i << ", j =" << j << ", num = " << num << endl;
            // printVector(nums);
        }
        j--;
        i++;
        for (; i < y + n; i++, num++) {
            nums[i][j] = num;
            // cout << "i = " << i << ", j =" << j << ", num = " << num << endl;
            // printVector(nums);
        }
        i--;
        j--;
        for (; j >= x; j--, num ++) {
            nums[i][j] = num;
            // cout << "i = " << i << ", j =" << j << ", num = " << num << endl;
            // printVector(nums);
        }
        j++;
        i--;
        for (; i > y; i--, num++) {
            nums[i][j] = num;
            // cout << "i = " << i << ", j =" << j << ", num = " << num << endl;
            // printVector(nums);
        }
    }
    vector<vector<int>> generateMatrix(int n) {
        int x = 0, y = 0, num = 1;
        vector<vector<int>> ans(n, vector<int>(n));
        while (n > 0) {
            drawEdge(x, y, n, num, ans);
            ++x, ++y;
            n -= 2;
        }
        return ans;
    }
    void printVector(const vector<vector<int>>& nums) {
        cout << "------" << endl;
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            cout << "[ ";
            for (int j = 0; j < n; ++j) {
                cout << nums[i][j] << " ";
            }
            cout << "]" << endl;
        }
        cout << "------" << endl;
    }
};
```

### 小结

先设计好需要使用什么样的功能，然后定义好函数接口，之后实现一个函数再调用。流程下来还是挺顺畅的，过程中因为一些变量名的疏忽导致 debug 花了一些时间。

另外学到了 python 中创建一个 n * n 矩阵的语法：`nums = [[0] * n for _ in range(n)]`

## 区间和

- [卡码网题目链接](https://kamacoder.com/problempage.php?pid=1070)
- [代码随想录链接](https://www.programmercarl.com/kamacoder/0058.%E5%8C%BA%E9%97%B4%E5%92%8C.html#%E6%80%9D%E8%B7%AF)

### 题目思路

本题需要对同一个数组上多个不同的区间计算区间和，如果每次都进行累加那么复杂度就会非常大，这种题目一个常见的思路就是计算前缀和，我猜测代码随想录也是用的这个方法。先写一版看看吧。

然后本题貌似是 ACM 模式的输入，需要自己实现输入输出的代码，问题看起来不大。

### 代码实现

python

```python
n = int(input())
array = []

# 输入数组
for _ in range(n):
    array.append(int(input()))

# 计算前缀和
prifix_sum_array = [array[0]]
for i in range(1, n):
    temp = prifix_sum_array[i - 1] + array[i]
    prifix_sum_array.append(temp)
prifix_sum_array.append(0) # 让下方求区间和时，a = 0 的情况计算正确

# 快速求区间和
while(True):
    try:
        a, b = map(int, input().split())
        a = int(a)
        b = int(b)
        range_sum = prifix_sum_array[b] - prifix_sum_array[a - 1]
        print(range_sum)
    except:
        break
```

C++

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> nums(n, 0);
    for (int& i : nums) {
        cin >> i;
    }
    // 计算前缀和：定义为 sum[nums[0], nums[n - 1]]
    vector<int> prefix_sum(n + 1, 0);
    for (int i = 1; i < prefix_sum.size(); ++i) {
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1];
    }
    // 计算区间和
    int left, right;
    while(cin >> left >> right) {
        cout << prefix_sum[right + 1] - prefix_sum[left] << endl;
    }
    return 0;
}
```

### 看录后想法

学到了 C++ 中如果大量输入数据使用 scanf 速度更快，而 scanf 的返回值是成功读取到的元素个数，读到 EOF 的时候返回 -1，因此可以 `while(~scanf(xx))` 来方便地读取数据，`~` 表示按位取反，如果正确读入则取反后应当是一个负数，会被转换成 true，读到 EOF 的话 -1 按位取反会变成 0（涉及补码 与 反码 的知识）。

## 开发商购买土地

- [题目链接](https://kamacoder.com/problempage.php?pid=1044)
- [代码随想录链接](https://www.programmercarl.com/kamacoder/0044.%E5%BC%80%E5%8F%91%E5%95%86%E8%B4%AD%E4%B9%B0%E5%9C%9F%E5%9C%B0.html)

### 题目思路

感觉本题直接去遍历求得最小值也不会很麻烦，但是有没有更优的算法呢？可以考虑上一题的前缀和的思路，创建一个行前缀和矩阵和列前缀和矩阵。嗯，因为分配方式的单一，或许前缀和不需要用矩阵来存，直接用一维数组存即可。

### 代码实现

```python
n, m = map(int, input().split())
land = [list(map(int, input().split())) for _ in range(n)]
# 按行切分的前缀和
prefix_row = [0] * n
prefix_row[0] = sum(land[0])
for i in range(1, n):
    prefix_row[i] = prefix_row[i - 1] + sum(land[i])
# 按列切分的前缀和
land_t = list(zip(*land)) # 转置
prefix_col = [0] * m
prefix_col[0] = sum(land_t[0])
for i in range(1, m):
    prefix_col[i] = prefix_col[i - 1] + sum(land_t[i])
# 按行切分计算价值差异
min_diff = prefix_row[n - 1]
for i in range(0, n - 1):
    diff = abs(prefix_row[n - 1] - prefix_row[i] * 2)
    min_diff = min(min_diff, diff)
# 按列切分计算价值差异
for i in range(0, m - 1):
    diff = abs(prefix_col[m - 1] - prefix_col[i] * 2)
    min_diff = min(min_diff, diff)
print(min_diff)
```

### 看录后想法

前缀和的代码与我的基本一致，不需要多看，而另一种思路我觉得不是那么的有意思，虽然复杂度一样，但是感觉不是那么的清晰。

### 小结

学到了 python 中可以使用 `list(zip(*land))` 来转置矩阵。

## 数组总结篇

数组篇主要理解了数组的基本概念，通过二分法的题目学习到了定义边界的开闭非常重要；后面学习了双指针法和前缀和的题目，还有一道螺旋矩阵是纯模拟题目。总的来说还是练了不少东西，比较有收获。但是后面发现自己工作后时间不足以支撑自己完成每道题用 Python 和 C++ 两种语言来做，后面只用 Python 来刷题了。

## 今日总结

工作之后每天刷题的时间实在是少，一开始好不适应，但是还是希望可以坚持下去。