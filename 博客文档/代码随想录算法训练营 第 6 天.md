# 代码随想录算法训练营 第 6 天 | 哈希表理论基础、有效的字母异位词、两个数组的交集、快乐数、两数之和

## 哈希表理论基础

- 哈希表用来快速判断一个元素是否出现在集合里。
- 哈希表会遇到哈希碰撞问题，一种思路是拉链法，另一种思路是线性探测法。
- C++ 中使用哈希法解决问题的时候，一般会选择如下三种数据结构：数组，set 和 map。
  - 对于 set 和 map，C++ 提供了以下的数据结构：
    - std::set 使用红黑树实现，有序，数值不可重复，数值不可更改，查询 O(logn), 增删 O(logn)
    - std::multiset 使用红黑树实现，有序，数值可重复，数值不可更改，查询 O(logn), 增删 O(logn)
    - std::unordered_set 使用哈希表实现，无序，数值不可重复，数值不可更改，查询 O(1), 增删 O(1)
    - std::map 使用红黑树实现，有序，数值不可重复，数值不可更改，查询 O(logn), 增删 O(logn)
    - std::multimap 使用红黑树实现，有序，数值可重复，数值不可更改，查询 O(logn), 增删 O(logn)
    - std::unordered_map 使用哈希表实现，无序，数值不可重复，数值不可更改，查询 O(1), 增删 O(1)
  - 本章 C++ 侧需要关注的主要就是 unordered_set 和 unordered_map 的用法，他们的区别主要是 set 主要存元素，而 map 存键值对。
- 哈希法本质是牺牲空间换取时间。

## 有效的字母异位词

- [题目链接](https://leetcode.cn/problems/valid-anagram/)
- [代码随想录链接](https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

既然只包含小写字母，只需要统计每个字符串各个字母的出现次数即可。然后进阶的题目，开数组就不太合适了，就开一个字典就行，键表示字符，值表示数字。

### 代码实现

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        letter_count = [0] * 26
        for letter in s:
            letter_count[ord(letter) - ord('a')] += 1
        for letter in t:
            letter_count[ord(letter) - ord('a')] -= 1
        for i in range(26):
            # 遇到不为 0 的元素立即 false 退出
            if letter_count[i]:
                return False
        return True
```

```Python
# 使用字典，应对不限于 26 个字母的情况
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        char_count = dict()
        for char in s:
            if char not in char_count.keys():
                char_count[char] = 1
            else:
                char_count[char] += 1
        for char in t:
            if char not in char_count.keys():
                return False
            else:
                char_count[char] -= 1
        for value in char_count.values():
            if value:
                return False
        return True
```

### 看录后想法

思路一致，无其他想法。

### 小结

无。

## 两个数组的交集

- [题目链接](https://leetcode.cn/problems/intersection-of-two-arrays/)
- [代码随想录链接](https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html)

### 题目思路

想想除了 n 平方复杂度的暴力搜索以外，还有没有其他的写法。使用集合貌似可以，先把 nums1 定义为一个集合，然后遍历 nums2 里的元素是否在 nums1 中存在即可，这样的复杂度整个下来应该是 n 的。

### 代码实现

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1 = set(nums1)
        ans = set()
        for num2 in nums2:
            if num2 in set1:
                ans.add(num2)
        return list(ans)
```

### 看录后想法

与代码随想录思路一致，无其他想法。

### 小结

无。

## 快乐数

- [题目链接](https://leetcode.cn/problems/happy-number/)
- [代码随想录链接](https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html)

### 题目思路

一个数只有两种可能，一种是变成 1 ，另一种是无限循环下去。既然是循环那就好办了，每次计算出的结果存到一个哈希表里，然后每次计算新的结果就查询有没有出现过，一旦出现过就说明是循环，就可以返回 false 了，一旦结果是 1 就可以返回 true 了。具体的复杂度与给出的数本身有关。

### 代码实现

```python
class Solution:
    def cal_happy(self, n: int) -> int :
        ns = str(n)
        ans = 0
        for char in ns:
            chari = int(char)
            ans += chari ** 2
        return ans
    def isHappy(self, n: int) -> bool:
        result_set = set()
        while True:
            n = self.cal_happy(n)
            if n == 1:
                return True
            if n in result_set:
                return False
            result_set.add(n)
```

### 看录后想法

思路一致，无其他想法。

### 小结

无。

## 两数之和

- [题目链接](https://leetcode.cn/problems/two-sum/)
- [代码随想录链接](https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 题目思路

第一种思路就是暴力搜索，复杂度是 n 平方。

第二种思路就是先求出 target 和其中一个数的差，然后查询这个差在不在数组里，可以用 set 来优化查询的复杂度。总体复杂度应该是 n。

### 代码实现

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        temp = 0
        ans = []
        nums_set = set(nums) # 设置一个集合，单纯用来查询
        for i in range(len(nums)):
            temp = target - nums[i]
            if temp in nums_set:
                # 继续遍历数组，看看能不能找到 temp
                for j in range(i + 1, len(nums)):
                    if nums[j] == temp:
                        ans.append(i)
                        ans.append(j)
                        return ans
        return ans
```

### 看录后想法

录里至少看到了 2 个优化点，第一个就是可以使用 dict，键用来存数字，值用来存下标，这样返回下标就会简单直接不少；第二个优化点就是先遍历，每次存储遍历后的结果，然后反向查询是否存在，这样一次遍历即可完成，逻辑更简洁。

优化的代码实现：

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_dict = dict()
        ans = list()
        for i in range(len(nums)):
            diff = target - nums[i]
            if diff in nums_dict.keys():
                ans.append(nums_dict[diff])
                ans.append(i)
                return ans
            nums_dict[nums[i]] = i
        return ans
```

### 小结

有时候代码确实可以有一点优化的空间，看录确实感觉有所收获的。
