[toc]

# 代码随想录算法训练营第 4 天 | 两两交换链表中的节点、删除链表的倒数第 N 个节点、链表相交、环形链表 II、链表总结篇

## 两两交换链表中的节点

- [题目链接](https://leetcode.cn/problems/swap-nodes-in-pairs/)
- [代码随想录链接](https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html)

### 题目思路

首先想到的可以用 3 个指针来进行操作，每次交换后面两个指针指向的节点。不过需要考虑一些边界条件，前两个节点的交换比较好解决，只需要创建一个虚拟头节点就可以统一操作。遍历到结尾的时候，需要考虑如果链表长度为奇数那么就不能交换，这个地方需要一些额外的逻辑。

### 代码实现

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 链表长度为 0 和 1 的时候比较特殊，需要单独处理
        if head is None:
            return None
        elif head.next is None:
            return head
        # 一般情况
        virtual_head = ListNode(0, head)
        pre = virtual_head
        cur = head
        nxt = cur.next
        while nxt is not None:
            # 经分析，结束条件是可以统一成 nxt is None 的，只要 nxt 不是 none 那么就可以继续操作
            # 翻转操作
            pre.next = nxt
            cur.next = nxt.next
            nxt.next = cur
            # 移动三个指针准备下次交换操作
            pre = pre.next.next
            cur = pre.next
            if cur is not None:
                nxt = cur.next
            else:
                nxt = None
        return virtual_head.next
        
```

### 看录后想法

题目比较基础，没有太多可以发挥的地方，所以我的思路和代码随想录几乎是一模一样的。

### 小结

没什么好说的。

## 删除链表的倒数第 N 个节点

- [题目链接](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
- [代码随想录链接](https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html)

### 题目思路

两个指针，第一个指针先跑 n 个距离，然后第二个指针从头开始和第一个指针一起动，等快指针跑到结尾慢指针就是答案。思路非常清晰，开始写题。

### 代码实现

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        fast = slow = head
        for _ in range(n):
            fast = fast.next
        if fast is None:
            # 说明要删的是第一个元素
            head = head.next
            return head
        while fast.next is not None:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return head
```

### 看录后想法

思路一致，无其他想法。

### 小结

无。

## 链表相交

- [题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)
- [代码随想录链接](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html)

### 题目思路

想到了一个思路，两个 head 分别使用快慢指针，然后快指针往后走，直到结尾停下来，同时设置一个变量统计快指针走了多长。然后比较两个快指针指向的元素地址是否一样，一样说明有交点，计算长度差值，然后让长的链表上的慢指针先走，直到两个慢指针能对齐之后，两个慢指针一起走，没走一步检测是否碰面，第一次碰面的结果就是交点。

### 代码实现

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        slowA = fastA = headA
        slowB = fastB = headB
        lenA = lenB = 0
        while fastA is not None:
            lenA += 1
            fastA = fastA.next
        while fastB is not None:
            lenB += 1
            fastB = fastB.next
        if fastA is not fastB:
            return None
        if lenA > lenB:
            for _ in range(lenA - lenB):
                slowA = slowA.next
        else:
            for _ in range(lenB - lenA):
                slowB = slowB.next
        while slowA is not slowB:
            slowA = slowA.next
            slowB = slowB.next
        return slowA
```

### 看录后想法

思路一致，感觉代码随想录的做法略难理解。

### 小结

无。

## 环形链表 II

- [题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/)
- [代码随想录链接](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html)

### 题目思路

如果不限制空间复杂度的话，我直接用 n 个指针去遍历就行了，不过题目肯定不是这个意思。

可以用两个指针，一个指针一次走两步，一个指针一次走一步，如果没有环的话，快指针可以访问到 None，如果有环的话，两个指针一定会相遇。但是如何确定入环的第一个点呢。

用数学方法思考一下，设时刻 t 后两个指针相遇了，快指针就走了 2t，慢指针走了 t，此时快慢指针一定是在环里相遇的，相差的 t 也一定是环的长度的整数倍，但是此时依然和进入点没关系。假设第二次相遇时走了 k 步，第二次套圈意味着快指针刚好比慢指针多走了 (k - t) 步，即圈的长度 len 是 (k - t)。

知道了圈的长度，重新将快慢指针放在 head，然后让快指针先跑 len 步，然后快慢指针一起同速前进，第一次相遇即是入圈点。

### 代码实现

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 排除和主逻辑不兼容的特殊情况
        if head is None:
            return None
        elif head.next is None:
            return None
        fast = slow = head
        # 第一次相遇
        while True:
            if fast is None:
                return None
            elif fast.next is None:
                return None
            slow = slow.next
            fast = fast.next.next
            if slow is fast:
                break
        # 求长度
        length = 0
        while True:
            fast = fast.next
            length += 1
            if slow is fast:
                break
        # 重设快慢指针，找入圈点
        slow = fast = head
        for _ in range(length):
            fast = fast.next
        while fast is not slow:
            fast = fast.next
            slow = slow.next
        return slow
```

### 看录后想法

并不理解代码随想录为什么要搞这么复杂，难道这种方法有其他地方的应用？目前还是觉得我的方法既简洁又清晰。

### 小结

无。

## 链表总结篇

- 写链表题如果开头处理麻烦可以添加一个虚拟头节点。
- 后面几道题里有意思的就是快慢指针可以用来灵活地解决一些带环的或是间距为 xxx 的题目。
- 其他就没什么东西了。