## 1 模板

### 1.1 模板的概念

模板就是建立**通用的模具**，大大**提高复用性**

例如生活中的模板

一寸照片模板：

![1547105026929](./assets/1%20%E6%A8%A1%E6%9D%BF/1%20%E6%A8%A1%E6%9D%BF-4521886.png)

PPT模板：

![1547103297864](./assets/1%20%E6%A8%A1%E6%9D%BF/1%20%E6%A8%A1%E6%9D%BF-1-4521886.png)

模板的特点：

* 模板不可以直接使用，它只是一个框架
* 模板的通用并不是万能的

---

### 1.2 函数模板

* C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板
* C++提供两种模板机制:**函数模板**和**类模板** 

#### 1.2.1 函数模板语法

函数模板作用：

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。

**语法：** 

```C++
template<typename T>
函数声明或定义
```

**解释：**

- template  ---  声明创建模板
- typename  --- 表面其后面的符号是一种数据类型，可以用class代替
- T    ---   通用的数据类型，名称可以替换，通常为大写字母

**示例：**

```cpp
#include <iostream>
using namespace std;
//函数模板
```

```cpp
//两个整型交换函数
void swap(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}

//交换两个浮点型函数
void swap(double& a, double& b) {
	double temp = a;
	a = b;
	b = temp;
}

void test01() {
	int a = 10, b = 20;
	swap(a, b);
	cout << "a=" << a << ", b=" << b << endl;
	double x = 3.14, y = 2.71;
	swap(x, y);
	cout << "x=" << x << ", y=" << y << endl;
}
```

```cpp
//函数模板
template<typename T>
//T 是一个通用数据类型
void swapT(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

void test02() {
	//使用函数模板
	char m = 'm', n = 'n';
	//方式1、自动类型推导
	swapT(m, n);
	cout << "m=" << m << ",n=" << n << endl;
	m = 'm', n = 'n';
	//方式2、显式指定类型
	swapT<char>(m, n);
	cout << "m=" << m << ",n=" << n << endl;
}
```

```cpp
int main() {
	test01();
	test02();
	return 0;
}
```

总结：

* 函数模板利用关键字 template
* 使用函数模板有两种方式：自动类型推导、显示指定类型
* 模板的目的是为了提高复用性，将类型参数化



#### 1.2.2 函数模板注意事项

注意事项：

* 自动类型推导，必须推导出一致的数据类型T，才可以使用


* 模板必须要确定出T的数据类型，才可以使用



**示例：**

```C++
#include <iostream>
using namespace std;
//函数模板注意事项
```

```cpp
template<typename T>
void mySwap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}

//1、自动类型推导，必须推导出一致的数据类型 T 才可以使用

void test01() {
	int a = 10;
	char b = 'b';
	//mySwap(a, b);
	//这种就错了，因为 a，b 的数据类型不一致
	cout << "a = " << a << ", b = " << b << endl;
}
```

```cpp
//2、模板必须要确定出 T 的数据类型，才可以使用

template<typename T>
void func() {
	cout << "func 的调用" << endl;
}

void test02() {
	//即便没有参数，没有传入指定数据类型，也是会报错的，必须显式指出
	//func();
	func<int>();
}
```

```cpp
int main() {
	test01();
	cout << endl << "------------" << endl << endl;
	test02();
	return 0;
}
```

**总结：**

* 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型



#### 1.2.3 函数模板案例

案例描述：

* 利用函数模板封装一个排序的函数，可以对**不同数据类型数组**进行排序
* 排序规则从大到小，排序算法为**选择排序**
* 分别利用**char数组**和**int数组**进行测试



示例：

```cpp
#include <iostream>
using namespace std;

//实现一个通用的数组排序函数
//规则 从大到小
//算法 选择
//测试 char 数组、int 数组
```

```cpp
//交换函数
template<typename T>
void mySwap(T& a, T& b) {
	T temp = a;
	a = b;
	b = temp;
}
```

```cpp
//排序算法
template<typename T>
void mySort(T arr[], int len) {
	for (int i = 0; i < len; i++) {
		int max = i; // 认定最大值的下标
		for (int j = i + 1; j < len; j++) {
			if (arr[max] < arr[j]) {
				//更新最大值的下标
				max = j;
			}
		}
		if (max != i) {
			//交换 max 和 i 下标的元素
			mySwap(arr[max], arr[i]);
		}
	}
}
```

```cpp
template<typename T>
void printArray(T arr[], int len) {
	for (int i = 0; i < len - 1; i++) {
		cout << arr[i] << " ";
	}
	cout << arr[--len] << endl;
}
```

```cpp
void test01() {
	//测试 char 数组
	char charArr[] = "badcfe";
	int num = sizeof(charArr) / sizeof(char);
	mySort(charArr, num);
	printArray(charArr, num);
}
```

```cpp
void test02() {
	//测试 int 数组
	int intArr[] = { 7,5,2,4,6 };
	int num = sizeof(intArr) / sizeof(int);
	mySort(intArr, num);
	printArray(intArr, num);
}
```

```cpp
int main() {
	test01();
	test02();
	return 0;
}
```

**总结：**模板可以提高代码复用，需要熟练掌握



#### 1.2.4 普通函数与函数模板的区别

**普通函数与函数模板区别：**

* 普通函数调用时可以发生自动类型转换（**隐式类型转换**）
* 函数模板调用时，如果利用自动类型推导，不会发生**隐式类型转换**
* 如果利用显示指定类型的方式，可以发生**隐式类型转换**



**示例：**

```C++
//普通函数
int myAdd01(int a, int b)
{
	return a + b;
}

//函数模板
template<class T>
T myAdd02(T a, T b)  
{
	return a + b;
}

//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';
	
	cout << myAdd01(a, c) << endl; //正确，将char类型的'c'隐式转换为int类型  'c' 对应 ASCII码 99

	//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换

	myAdd02<int>(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T



#### 1.2.5 普通函数与函数模板的调用规则

调用规则如下：

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生**重载**
4. 如果函数模板可以产生更好的匹配,优先调用函数模板

**示例：**

```cpp
#include <iostream>
using namespace std;

//普通函数与函数模板调用规则
//1、如果函数模板和普通函数都可以调用的话，优先调用普通函数
//2、可以通过空模板参数列表的方式强制调用函数模板
//3、函数模板也可以发生函数重载
//4、如果函数模板可以产生更好的匹配，优先调用函数模板
```

```cpp
void myPrint(int a, int b) {
	cout << "调用的是普通函数" << endl;
}
```

```cpp
template<typename T>
void myPrint(T a, T b) {
	cout << "调用的是函数模板" << endl;
}
```

```cpp
void test01() {
	//1、如果函数模板和普通函数都可以调用的话，优先调用普通函数
	int a = 10;
	int b = 20;
	myPrint(a, b);//调用的是普通函数
	//即便普通函数只有声明没有实现，也还是调用普通函数然后报错而已
}
```

```cpp
void test02() {
	//2、可以通过空模板参数列表的方式强制调用函数模板
	int a = 10;
	int b = 20;
	myPrint<>(a, b);//调用的是函数模板
}
```

```cpp
template<typename T>
void myPrint(T a, T b, T c) {
	cout << "调用的是重载了的模板" << endl;
}
void test03() {
	//3、函数模板也可以发生函数重载
	myPrint(1, 2, 3);//调用的是重载了的模板
}
```

```cpp
void test04() {
	//4、如果函数模板可以产生更好的匹配，优先调用函数模板
	char c1 = 'a';
	char c2 = 'b';
	myPrint(c1, c2);//调用的是函数模板（而不是隐式类型转换成int）
}
```

```cpp
int main() {
	test01();
	test02();
	test03();
	test04();
	return 0;
}
```

**总结：** 既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性。



#### 1.2.6 模板的局限性

**局限性：**

* 模板的通用性并不是万能的

**例如：**

```C++
template<class T>
void f(T a, T b) { 
    a = b;
}
```

在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了



**再例如：**

```C++
template<class T>
void f(T a, T b) { 
    if(a > b) { ... }
}
```

在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行

因此C++为了解决这种问题，提供模板的重载，可以为这些**特定的类型**提供**具体化的模板**

**示例：**

```cpp
#include <iostream>
using namespace std;

//模板的局限性
//模板并不是万能的，有些特定的数据类型，需要用具体话的方式实现

class Person {
public:
	Person(string name, int age) :name(name), m_Age(age) {}
	string name;
	int m_Age;
};

```

```cpp
//对比两个数据是否相等
template<typename T>
bool myCompare(T &a, T &b) {
	if (a == b) {
		return true;
	}
	return false;
}
```

```cpp
//利用具体化的 Person 的版本实现代码
//具体化会优先调用，而不是走上面那个 myCompare
template<> bool myCompare(Person& a, Person& b) {
	if (a.m_Age == b.m_Age && a.name == b.name)
		return true;
	return false;
}
```

```cpp
void test01() {
	int a = 10;
	int b = 20;
	bool ret = myCompare(a, b);
	if (ret) cout << "a == b" << endl;
	else cout << "a != b" << endl;
}
```

```cpp
void test02() {
	//测试类作为参数传入模板进行比较
	//直接让 Person 类进行 == 比较肯定是错的
	//第一种解法就是重载 operator==，但是有点麻烦
	//第二种解法就是重载一个 Person
	Person p1("Tom", 10);
	Person p2("Tom", 10);
	bool ret = myCompare(p1, p2);
	if (ret) cout << "p1 == p2" << endl;
	else cout << "p1 != p2" << endl;
}
```

```cpp
int main() {
	test01();
	test02();
	return 0;
}
```

**总结：**

* 利用具体化的模板，可以解决自定义类型的通用化
* 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板



### 1.3 类模板

#### 1.3.1 类模板语法

类模板作用：

* 建立一个通用类，类中的**成员** 数据类型可以不具体制定，用一个**虚拟的类型**来代表。

**语法：** 

```c++
template<typename[/class] T>
类
```

**解释：**

`template`  ---  声明创建模板

`typename`  --- 表面其后面的符号是一种数据类型，可以用class代替

`T`    ---   通用的数据类型，名称可以替换，通常为大写字母

**示例：**

```C++
#include <string>
//类模板
template<class NameType, class AgeType> 
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->mName = name;
		this->mAge = age;
	}
	void showPerson()
	{
		cout << "name: " << this->mName << " age: " << this->mAge << endl;
	}
public:
	NameType mName;
	AgeType mAge;
};

void test01()
{
	// 指定NameType 为string类型，AgeType 为 int类型
	Person<string, int>P1("孙悟空", 999);
	P1.showPerson();
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

总结：类模板和函数模板语法相似，在声明模板 template 后面加类，此类称为类模板



#### 1.3.2 类模板与函数模板区别

类模板与函数模板区别主要有两点：

1. 类模板没有自动类型推导的使用方式，每次调用必须**显式指定类型** 。
2. 类模板在模板参数列表中可以有默认参数，而函数模板是不可以有的。

**示例：**

```cpp
#include <iostream>
#include <string>
using namespace std;

//类模板与函数模板的区别
//1、类模板没有自动类型推导的使用方式
//2、类模板在模板的参数列表里可以用默认参数
```

```cpp
template<class NameType = string, class AgeType = int>
class Person {
public:
	Person(NameType name, AgeType age) :
		m_Name(name), m_Age(age) {}
	void showPerson() {
		cout << "name = " << m_Name << endl;
		cout << "age = " << m_Age << endl;
	}
public:
	NameType m_Name;
	AgeType m_Age;
};
```

```cpp
void test01() {
	//Person p("孙悟空", 999); //错误，无法用自动类型推导
	Person<> p1("孙悟空", 999); //由于默认参数，省略 string,int，但是<>不能省
	p1.showPerson();
}

int main() {
	test01();
	return 0;
}
```

总结：

* 类模板使用只能用**显示指定类型**方式
* 类模板中的模板参数列表可以有**默认参数**



#### 1.3.3 类模板中成员函数创建时机

类模板中成员函数和普通类中成员函数创建时机是有区别的：

* 普通类中的成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建

**示例：**

```cpp
#include <iostream>
using namespace std;

//类模板中成员函数创建时机
//结论：类模板中成员函数在调用时才会创建
```

```cpp
class Person1 {
public:
	void showPerson1() {
		cout << "Person1 show" << endl;
	}
};

class Person2 {
public:
	void showPerson2() {
		cout << "Person1 show" << endl;
	}
};
```

```cpp
template<class T>
class MyClass {
public:
	T obj;
	//类模板中的成员函数
	//由于C++类模板成员函数调用时创建，所以这里编译不会报错
	void func1() {
		obj.showPerson1();
	}
	void func2() {
		obj.showPerson2();
	}
};

```

```cpp
void test01() {
	MyClass<Person1> m;
	m.func1();
	//m.func2(); // 报错，同样说明函数调用时才会创建成员函数
}

int main() {
	return 0;
}
```

**总结：**

类模板中的成员函数并不是一开始就创建的，在调用时才去创建。



#### 1.3.4 类模板对象做函数参数

学习目标：

* 类模板实例化出的对象，向函数传参的方式



一共有三种传入方式：

1. 指定传入的类型   --- 直接显示对象的数据类型
2. 参数模板化           --- 将对象中的参数变为模板进行传递
3. 整个类模板化       --- 将这个对象类型 模板化进行传递

**示例：**

```cpp
#include <iostream>
#include <string>
using namespace std;

//类模板对象作函数参数
template <class T1, class T2>
class Person {
public:
    Person(T1 name, T2 age) {
        this->m_Name = name;
        this->m_Age = age;
    }
    void showPerson() {
        cout << "name: " << this->m_Name << endl;
        cout << "age: " << this->m_Age << endl;
    }
public:
    T1 m_Name;
    T2 m_Age;
};
```

```cpp
//1、指定传入类型
void printPerson1(Person<string, int> &p) {
    p.showPerson();
}
void test01() {
    Person<string,int> p("孙悟空",100);
    printPerson1(p);
}
```

```cpp
//2、参数模板化
template<class T1, class T2>
void printPerson2(Person<T1,T2>& p) {
    p.showPerson();
    cout << "T1 的类型是 " << typeid(T1).name() << endl;
    cout << "T2 的类型是 " << typeid(T2).name() << endl;
}
void test02() {
    Person<string, int> p("猪八戒",90);
    printPerson2(p);
}
```

```cpp
//3、整个类模板化
template<class T>
void printPerson3(T p) {
    p.showPerson();
    cout << "T 的数据类型为" << typeid(T).name() << endl;
}
void test03() {
    Person<string, int>p("唐僧",30);
    printPerson3(p);
}
```

```cpp
int main() {
    test01();
    cout << "-----" << endl;
    test02();
    cout << "-----" << endl;
    test03();
    return 0;
}
```



**总结：**

* 通过类模板创建的对象，可以有三种方式向函数中进行传参
* 使用比较广泛是第一种：指定传入的类型



#### 1.3.5 类模板与继承

当类模板碰到继承时，需要注意一下几点：

* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
* 如果不指定，编译器无法给子类分配内存
* 如果想灵活指定出父类中 T 的类型，子类也需变为类模板



**示例：**

```cpp
#include <iostream>
using namespace std;
//类模板与继承
//父类
template <class T>
class Base {
    T m;
};
//子类
//class Son :public Base {
    // 错误，必须要知道父类中的 T 的数据类型才能继承给子类
//};
class Son :public Base<int> {
    // 正确，这样就可以知道 T 的数据类型了
};
```

```cpp
// 如果想灵活指定父类中 T 的类型，子类也需要变为类模板
template <class T1, class T2>
class Son2 :public Base<T2> {
public:
    Son2() {
        cout << typeid(T1).name() << endl;
        cout << typeid(T2).name() << endl;
    }
};

```

```cpp
void test01() {
    Son s;
}
void test02() {
    Son2<int,string> s;
}
int main() {
    test01();
    cout << "------" << endl;
    test02();
    return 0;
}
```

**总结：** 如果父类是类模板，子类需要指定出父类中T的数据类型。



#### 1.3.6 类模板成员函数类外实现

学习目标：能够掌握类模板中的成员函数类外实现



**示例：**

```C++
#include <iostream>
#include <string>
using namespace std;

//类模板成员函数类外实现
template<class T1, class T2>
class Person {
public:
    Person(T1 name, T2 age);
    void showPerson();
    T1 m_Name;
    T2 m_Age;
};

```

```cpp
//构造函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age){
    this->m_Name = name;
    this->m_Age = age;
}
//成员函数的类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
    cout << "姓名：" << this->m_Name << endl;
    cout << "年龄：" << this->m_Age << endl;
}
```

```cpp
void test() {
    Person<string, int> p("Tom", 20);
    p.showPerson();
}

int main() {
    test();
    return 0;
}
```

**注意：**

类外实现时，作用域声明的时候需要加上模板参数列表。



#### 1.3.7 类模板分文件编写

**学习目标：**

* 掌握类模板成员函数分文件编写产生的问题以及解决方式

**问题：**

* 类模板中成员函数在调用的时候才创建，导致类模板编译后无法链接到 .cpp 文件（main 文件中仅 include 类头文件的情况）。

**解决：**

* 解决方式1：直接包含.cpp源文件（实际上不这么用）
* 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制

**示例：**

person.hpp中代码：

```C++
#pragma once
#include <iostream>
using namespace std;
#include <string>

template<class T1, class T2>
class Person {
public:
	Person(T1 name, T2 age);
	void showPerson();
public:
	T1 m_Name;
	T2 m_Age;
};

//构造函数 类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) {
	this->m_Name = name;
	this->m_Age = age;
}

//成员函数 类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
	cout << "姓名: " << this->m_Name << " 年龄:" << this->m_Age << endl;
}
```

类模板分文件编写.cpp中代码

```C++
#include<iostream>
using namespace std;

//#include "person.h"
#include "person.cpp" //解决方式1，包含cpp源文件

//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp
#include "person.hpp"
void test01()
{
	Person<string, int> p("Tom", 10);
	p.showPerson();
}

int main() {
	test01();
	system("pause");
	return 0;
}
```

总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp



#### 1.3.8 类模板与友元

**学习目标：**

* 掌握类模板配合友元函数的类内和类外实现



-   全局函数**类内**实现 - 直接在**类内声明友元**即可
-   全局函数**类外**实现 - 需要**提前让编译器知道**全局函数的存在



**示例：**

```C++
#include <iostream>
using namespace std;
//类模板与友元
//通过全局函数打印 Person 信息

//声明 Person 类从而让下面的函数可以正常调用
template<class T1, class T2>
class Person;
//类外实现，写在类中声明前面，让编译器知道有这个函数的存在
template<class T1, class T2>
void printPerson2(Person<T1, T2> p) {
    cout << "类外实现：name = " << p.m_Name << endl;
    cout << "类外实现：age = " << p.m_Age << endl;
}
```

```cpp
template<class T1, class T2>
class Person{
    //全局函数 类内实现
    friend void printPerson(Person<T1, T2> p) {
        cout << "name = " << p.m_Name << endl;
        cout << "age = " << p.m_Age << endl;
    }
    //全局函数类外实现
    //加一个空模板的参数列表
    //如果全局函数是类外实现的，需要让编译器提前知道这个函数的存在
    friend void printPerson2<>(Person<T1, T2> p);
public:
    Person(T1 name, T2 age){
        this->m_Name = name;
        this->m_Age = age;
    }
private:
    T1 m_Name;
    T2 m_Age;
};
```

```cpp
void test01() {
    Person<string, int> p("Tom",20);
    printPerson(p);
}
void test02() {
    Person<string, int> p("Tom",20);
    printPerson2(p);
}

int main() {
    test01();
    test02();
    return 0;
}
```

**总结：** 建议全局函数做类内实现，用法简单，而且编译器可以直接识别。类外实现过于复杂，很多时候都是没有必要的。



#### 1.3.9 类模板案例

案例描述:  实现一个通用的**数组类**，要求如下：

* 可以对内置数据类型以及自定义数据类型的数据进行存储
* 将数组中的数据存储到堆区
* 构造函数中可以传入数组的容量
* 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
* 提供尾插法和尾删法对数组中的数据进行增加和删除
* 可以通过下标的方式访问数组中的元素
* 可以获取数组中当前元素个数和数组的容量

**示例：**

`myArray.hpp`中代码

```C++
//自己的通用数组类
#pragma once
#include <iostream>
using namespace std;
```

```cpp
template <typename T>
class MyArray{
public:
    //有参构造 参数 容量
    MyArray(int capacity);
    //拷贝构造，实现深拷贝
    MyArray(const MyArray& other);
    //重载 op= ，实现深拷贝
    MyArray<T>& operator=(const MyArray& other);
    //析构函数释放堆区内容
    ~MyArray();
    //尾插法
    void push_back(const T& val);
    //尾删法
    void pop_back();
    //通过下标方式访问数据
    T& operator[](int index);
    //返回数组容量
    int getCapacity() const;
    //返回数组大小
    int getSize() const;
private:
    T* pAddress; // 指针指向堆区开辟的真实数组
    int m_Capacity; // 数组容量
    int m_Size; // 数组实际大小
};
```

```cpp
template <typename T>
MyArray<T>::MyArray(int capacity){
    //cout << "MyArray 有参构造调用" << endl;
    this->m_Capacity = capacity;
    this->m_Size = 0;
    this->pAddress = new T[this->m_Capacity];
}

template<typename T>
MyArray<T>::MyArray(const MyArray &other) {
    //cout << "MyArray 拷贝构造调用" << endl;
    this->m_Capacity = other.m_Capacity;
    this->m_Size = other.m_Size;
    this->pAddress = new T[this->m_Capacity];
    for (int i = 0; i < this->m_Size; i++) {
        this->pAddress[i] = other.pAddress[i];
    }
}
```

```cpp
template<typename T>
MyArray<T>& MyArray<T>::operator=(const MyArray& other) {
    //cout << "MyArray operator= 调用" << endl;
    // 考虑自赋值问题
    if (this == &other) {
        return *this;
    }
    // 判断原来堆区是否有数据
    if (this->pAddress != nullptr) {
        delete[] this->pAddress;
        this->pAddress = nullptr;
        this->m_Capacity = 0;
        this->m_Size = 0;
    }
    this->m_Capacity = other.m_Capacity;
    this->m_Size = other.m_Size;
    this->pAddress = new T[this->m_Capacity];
    for (int i = 0; i < this->m_Size; i++) {
        this->pAddress[i] = other.pAddress[i];
    }
    return *this;
}
```

```cpp
template<typename T>
MyArray<T>::~MyArray() {
    //cout << "MyArray 析构函数调用" << endl;
    if (this->pAddress!=nullptr) {
        delete[] pAddress;
    }
    pAddress = nullptr;
}

template<typename T>
void MyArray<T>::push_back(const T& val) {
    // 判断容量是否已经等于大小
    if (this->m_Capacity == this->m_Size) {
        cout << "容量已满" << endl;
        return;
    }
    this->pAddress[this->m_Size] = val;
    this->m_Size++;
}
```

```cpp
template<typename T>
void MyArray<T>::pop_back() {
    // 防止下溢
    if (this->m_Size == 0) {
        return;
    }
    --this->m_Size;
}

template<typename T>
T& MyArray<T>::operator[](int index) {
    return this->pAddress[index];
}

template<typename T>
int MyArray<T>::getCapacity() const {
    return this->m_Capacity;
}

template<typename T>
int MyArray<T>::getSize() const {
    return this->m_Size;
}
```

类模板案例—数组类封装.cpp中

```C++
// 案例描述:  实现一个通用的数组类，要求如下：
//
// * 可以对内置数据类型以及自定义数据类型的数据进行存储
// * 将数组中的数据存储到堆区 -- DONE
// * 构造函数中可以传入数组的容量 -- DONE
// * 提供对应的拷贝构造函数以及operator=防止浅拷贝问题 -- DONE
// * 提供尾插法和尾删法对数组中的数据进行增加和删除
// * 可以通过下标的方式访问数组中的元素
// * 可以获取数组中当前元素个数和数组的容量
```

```cpp
#include <iostream>
#include <string>
#include "MyArray.hpp"
using namespace std;

void printIntArr(MyArray<int>& arr) {
    cout << "打印 Arr：";
    cout << '[';
    for (int i = 0; i < arr.getSize() - 1; i++) {
        cout << arr[i] << ", ";
    }
    cout << arr[arr.getSize() - 1] << ']'<< endl;
}
void test01() {
    MyArray<int> arr1(5);
    // MyArray<int> arr2(arr1);
    // arr2 = arr1;
    // 利用尾插法向数组中插入数据
    for (int i = 0; i < 5; i++) {
        arr1.push_back(i);
    }
    cout << "arr1 的打印输出为：" << endl;
    printIntArr(arr1);
    cout << "arr1 的容量为：" << arr1.getCapacity() << endl;
    cout << "arr1 的大小为：" << arr1.getSize() << endl;
    // 测试尾删法
    MyArray<int> arr2(arr1);
    arr2.pop_back();
    cout << "arr2 的容量为：" << arr2.getCapacity() << endl;
    cout << "arr2 的大小为：" << arr2.getSize() << endl;
}
```

```cpp
// 测试自定义数据类型
class Person {
public:
    Person() {
        // 必须实现默认构造函数，因为 new 分配空间的时候会调用它
        this->m_Name = "空名字";
        this->m_Age = 0;
    }
    Person(string const & name, int const & age) {
        this->m_Name = name;
        this->m_Age = age;
    }
    string m_Name;
    int m_Age;
};

void printPersonArr(MyArray<Person>& arr) {
    for (int i = 0; i < arr.getSize(); ++i) {
        cout << "姓名：" << arr[i].m_Name << "\t年龄：" << arr[i].m_Age << endl;
    }
}

void test02() {
    MyArray<Person> arr(10);
    Person p1("孙悟空",30);
    Person p2("韩信",20);
    Person p3("妲己", 18);
    Person p4("王昭君", 15);
    Person p5("赵云",24);
    arr.push_back(p1);
    arr.push_back(p2);
    arr.push_back(p3);
    arr.push_back(p4);
    arr.push_back(p5);
    printPersonArr(arr);
}
```

```cpp
int main() {
    test01();
    test02();
    return 0;
}
```

**总结：**

能够利用所学知识点实现通用的数组

