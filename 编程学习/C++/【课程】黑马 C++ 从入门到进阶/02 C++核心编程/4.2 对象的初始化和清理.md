### 4.2 对象的初始化和清理

*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。



#### 4.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

-   一个对象或者变量没有初始状态，对其使用后果是未知
-   同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

C++ 利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**



* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。



**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次



**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次



```C++
#include <iostream>
using namespace std;

class Person {
public:
    //构造函数
    Person() {
        cout << "Person的构造函数调用" << endl;
    }
    //析构函数
    ~Person() {
        cout << "Person的析构函数调用" << endl;
    }
};

void test01() {
    Person p;
}

int main() {
    test01();
    return 0;
}
```



#### 4.2.2 构造函数的分类及调用

两种分类方式：

- 按参数分为： 有参构造和无参（默认）构造
- 按类型分为： 普通构造和拷贝构造
    - 注意拷贝构造函数的参数里应该写 `const 类名 & XX`，即使用常量引用的方式。

三种调用方式：

- 括号法
- 显示法
- 隐式转换法

**示例：**

```cpp
#include <iostream>
using namespace std;
```

```cpp
class Person {
public:
	Person() {
		age = 0;
		cout << "Person的无参（默认）构造" << endl;
	}
	Person(int a) {
		age = a;
		cout << "Person的有参构造" << endl;
	}
	Person(const Person& p) {
		age = p.getAge();
		cout << "Person的拷贝构造" << endl;
	}
	~Person() {
		cout << "Person的析构函数" << endl;
	}
	int getAge() const {
		return age;
	}
private:
	int age;
};
```

```cpp
//调用
void test01() {
	//默认构造(不要写括号，空括号会被认为是一个函数声明)
	Person p1;
	//1.括号法
	Person p2(10); //有参构造
	Person p3(p1); //拷贝构造
	//2.显式法
	Person p4 = Person(10); //有参构造
	Person p5 = Person(p2); //拷贝构造
	//3.隐式法
	Person p6 = 10; //有参构造 相当于 Person p7(10);
	Person p7 = p2; //拷贝构造
}
```

```C++
int main() {
	test01();
	return 0;
}
```

**注意：**

1.   使用无参构造创建对象的时候，不要加括号，否则会被认为是函数声明。

```cpp
//Right
Person p;
//Wrong
Person p();
```

2.   所谓显式构造其实就是先创建一个匿名对象（等号右边的表达式），然后赋值给刚初始化的对象。

```cpp
Person p1 = Person(10);
Person(10); //对于这里，如果单独一个匿名对象，执行完这行编译器会立即自动回收掉匿名对象。
```

1.   不要利用拷贝构造函数来初始化一个匿名对象。

```cpp
...
Person p3(10);
...
//Wrong
Person(p3); // 编译器会自动转义为 Person p3;将会造成重定义的问题。
```



#### 4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

* 使用拷贝构造的方式实例化一个新对象
* 函数值传递一个对象，会拷贝出一个副本
* 以值方式返回局部对象，会拷贝出一个副本（编译器可能会优化）

**示例：**

```cpp
#include <iostream>
using namespace std;

//拷贝构造函数的调用时机
//1、使用一个已经创建完毕的对象来初始化一个新对象
//2、值传递的方式给函数传值
//3、值方式返回局部对象
```

```C++
class Person {
public:
	Person() {
		cout << "Person 的默认构造" << endl;
	}
	Person(int age) {
		m_Age = age;
		cout << "Person 的有参构造" << endl;
	}
	Person(const Person& p) {
		m_Age = p.m_Age;
		cout << "Person 的拷贝构造" << endl;
	}
	~Person() {
		cout << "Person 的析构函数调用" << endl;
	}
	int m_Age;
};
```

```cpp
int main() {
	system("pause");
	return 0;
}
```

**1、使用一个已经创建完毕的对象来初始化一个新对象**

```cpp
//1、使用一个已经创建完毕的对象来初始化一个新对象
void test01() {
	Person p1(20);
	Person p2(p1);
	cout << "p2.age = " << p2.m_Age << endl;
}
```

**2、值传递的方式给函数传值**

```cpp
//2、值传递的方式给函数传值
void func(Person p) {}
void test02() {
	Person p;
	func(p);//值传递会调用一次拷贝构造
}
```

**3、值方式返回局部对象**

```cpp
//3、值方式返回局部对象
//本例可能被编译器RV0优化导致不会触发拷贝构造
Person func2() {
	Person p1;
	cout << (int*) & p1 << endl;
	return p1;
}
void test03() {
	Person p = func2();
	cout << (int*)&p << endl;
}
```



#### 4.2.4 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)
2．默认析构函数(无参，函数体为空)
3．默认拷贝构造函数，对属性进行值拷贝



构造函数调用规则如下：

* 如果用户定义**有参**构造函数，C++不再提供**默认无参构造**，但是会提供**默认拷贝构造**。
* 如果用户定义**拷贝**构造函数，C++不会再提供**其他构造函数**。

示例：

```cpp
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
    }
    
	int age;
};
```

```cpp
void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout << "p2的年龄为： " << p2.age << endl;
}
```

```cpp
void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}
```

```C++
int main() {
	test01();
	system("pause");
	return 0;
}
```



#### 4.2.5 深拷贝与浅拷贝

深浅拷贝是面试经典问题，也是常见的一个坑。

- 浅拷贝：简单的赋值拷贝操作
- 深拷贝：在堆区重新申请空间，进行拷贝操作

**示例：**

```cpp
#include <iostream>
using namespace std;
```

```cpp
class Person {
public:
	Person() {
		cout << "调用了一次默认构造函数" << endl;
	}
	Person(int age, int height) {
		cout << "调用了一次有参构造函数" << endl;
		m_age = age;
		m_height = new int(height);
	}
	//拷贝构造函数
	Person(const Person& p) {
		cout << "调用了一次拷贝构造函数" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		//m_height = p.m_height;//浅拷贝
		m_height = new int(*p.m_height);//深拷贝
	}
	~Person() {
		cout << "调用了一次析构函数" << endl;
		if (m_height != nullptr) {
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};
```

```cpp
void test01() {
	Person p1(18, 180);
	Person p2(p1);
	cout << "p1的年龄：" << p1.m_age << "身高：" << *p1.m_height << endl;
	cout << "p2的年龄：" << p2.m_age << "身高：" << *p2.m_height << endl;
}
```

```cpp
int main() {
	test01();
	return 0;
}
```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题



#### 4.2.6 初始化列表

**作用：**

C++提供了初始化列表语法，用来初始化属性

**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`

**示例：**

```C++
#include <iostream>
using namespace std;
```

```cpp
class Person {
public:
	int m_A;
	int m_B;
	int m_C;
public:
	//传统初始化操作
	/*
	Person(int a, int b, int c) {
		m_A = a;
		m_B = b;
		m_C = c;
	}
	*/
	//初始化列表方式（写死初值）
	Person() :m_A(10), m_B(20), m_C(30) {}
	//初始化列表方式（灵活）
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
};
```

```cpp
void test01() {
	//传统初始化操作
	Person p(10, 20, 30);
	cout << "m_A: " << p.m_A << endl;
	cout << "m_B: " << p.m_B << endl;
	cout << "m_C: " << p.m_C << endl;
}
```

```cpp
void test02() {
	//初始化列表方式（写死初值）
	Person p;
	cout << "m_A: " << p.m_A << endl;
	cout << "m_B: " << p.m_B << endl;
	cout << "m_C: " << p.m_C << endl;
}
```

```cpp
void test03() {
	//初始化列表方式（灵活）
	Person p(10, 20, 30);
	cout << "m_A: " << p.m_A << endl;
	cout << "m_B: " << p.m_B << endl;
	cout << "m_C: " << p.m_C << endl;
}
```

```cpp
int main() {
	test02();
	test03();
	return 0;
}
```



#### 4.2.7 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员。

例如：

```C++
class A {}
class B
{
    A a；
}
```



B类中有对象A作为成员，A为对象成员

那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？

下面的例子会给出答案。

**示例：**

```C++
#include <iostream>
#include <string>
using namespace std;
```

```cpp
//类对象作为类成员
class Phone {
public:
	string m_pname;
	Phone(string pName) {
		m_pname = pName;
		cout << "Phone的构造函数调用" << endl;
	}
};
```

```cpp
class Person {
public:
	//姓名
	string m_name;
	//手机
	Phone m_phone;
public:
	Person(string name, string pName) :m_name(name), m_phone(pName) {
		cout << "Person的构造调用" << endl;
	}
};
```

```cpp
void test01() {
	Person p("张三", "苹果");
	cout << p.m_name << "拿着：" << p.m_phone.m_pname << endl;
}
```

```cpp
int main() {
	test01();
	return 0;
}
```

结果：

![image-20250316215017831](./assets/image-20250316215017831.png)

说明还是先调用 A 的构造函数，再调用 B 的构造函数，然后析构相反。整体类似一个 栈 的结构，实际上应该也是。



#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

*  静态成员变量
    *  所有对象共享同一份数据
    *  在编译阶段分配内存
    *  类内声明，类外初始化
*  静态成员函数
    *  所有对象共享同一个函数
    *  静态成员函数只能访问静态成员变量

**示例1 ：** 静态成员变量

```cpp
#include <iostream>
using namespace std;
```

```cpp
//静态成员变量
class Person {
public:
	//1、所有对象都共享统一份数据
	//2、编译阶段就分配内存
	//3、类内声明，类外初始化操作
	static int m_A;
	//静态成员变量也是有访问权限的
private:
	static int m_B;
};
int Person::m_A = 100;//类外初始化操作
int Person::m_B = 235;
```

```cpp
void test01() {
	Person p1;
	cout << p1.m_A << endl;
	Person p2;
	p2.m_A = 200;
	cout << p1.m_A << endl;
}
```

```cpp
void test02() {
	//静态成员变量不属于某个对象上，所有对象都共享同一份数据
	//因此静态成员变量有两种访问方式
	//1、通过对象进行访问
	Person p;
	cout << p.m_A << endl;
	//2、通过类名进行访问
	cout << Person::m_A << endl;
	//cout << Person::m_B << endl; //访问权限限制，无法访问
}
```

```C++
int main() {
	test01();
	test02();
	return 0;
}
```

**注意：**

- 需要在类外进行初始化操作。
- 类外可以用类名直接访问。
- 静态成员变量也有访问权限的限制。

****

**示例2：** 静态成员函数

```C++
#include <iostream>
using namespace std;

//静态成员函数
//1、所有对象都共享同一个函数
//2、静态成员函数只能访问静态成员变量
```

```cpp
class Person {
public:
	static void func() {
		m_A = 100;//静态成员函数访问静态成员变量
		//m_B = 200;//不可以访问，报错
		cout << "ststic void func() 的调用" << endl;
	}
	static int m_A;
	int m_B;
private:
	//静态成员函数也有访问限制
	static void func2() {}
};
int Person::m_A = 0;
```

```cpp
void test01() {
	//1、通过对象访问
	Person p;
	p.func();
	//2、通过类名访问
	Person::func();
	//Person::func2();//报错，访问限制错
}
```

```cpp
int main() {
	test01();
	return 0;
}
```

**注意：**

- 所有对象都共享同一个静态成员函数
- 静态成员函数只能访问静态成员变量
- 静态成员函数也有访问权限的控制

