### 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

#### 4.5.1 加号运算符重载

![](./assets/4.5%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-1.png)

作用：实现两个自定义数据类型相加的运算

```C++
#include <iostream>
using namespace std;
//加号运算符重载
//1、成员函数重载 +
//2、全局函数重载 +
```

```cpp
class Person {
public:
    //1、成员函数重载 +
    // Person operator+(Person& p) {
    //     Person temp;
    //     temp.m_A = this->m_A + p.m_A;
    //     temp.m_B = this->m_B + p.m_B;
    //     return temp;
    // }
    int m_A;
    int m_B;
};
```

```cpp
//2、全局函数重载 +
Person operator+(Person& p1, Person& p2) {
    Person temp;
    temp.m_A = p1.m_A + p2.m_A;
    temp.m_B = p1.m_B + p2.m_B;
    return temp;
}
```

```cpp
void test01() {
    Person p1;
    p1.m_A = 10;
    p1.m_B = 10;
    Person p2;
    p2.m_A = 10;
    p2.m_B = 10;
    Person p3 = p1 + p2;
    cout << "p3.m_A = " << p3.m_A << endl;
    cout << "p3.m_B = " << p3.m_B << endl;
}

int main() {
    test01();
    return 0;
}
```

说明：

```cpp
//成员函数重载本质调用
Person p3 = p1.operator+(p2);

//全局函数重载本质调用
Person p3 = operator+(p1, p2);
```

此外，运算符重载也可以写多个重载版本，更加灵活。例如：

```cpp
Person operator+(Person& p1,Person& p2);//实现 p3 = p1 + p2;
Person operator+(Person&p, int a);//实现 p3 = p1 + 3;
Person operator+(int a, Person&p);//实现 p3 = 3 + p1;
```

 >总结1：对于**内置的**数据类型的表达式的的运算符是不可能改变的
 >
 >总结2：不要滥用运算符重载



#### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型。（`cout << a << endl;`）

```C++
#include <iostream>
using namespace std;

//左移运算符重载
```

```cpp
class Person {
	friend ostream& operator<<(ostream& cout, Person& p);
private:
	//利用成员函数重载左移运算符，会发现没法写
	//不使用成员函数重载左移运算符，无法保证 cout << p << endl;的形式
	/*void operator<<(Person& p) {

	}*/
	int m_A;
	int m_B;
public:
	Person(int a, int b) :m_A(a), m_B(b) {}
};
```

```cpp
//利用全局函数重载左移运算符
ostream& operator<<(ostream& cout, Person& p) {
	cout << "m_A = " << p.m_A << endl;
	cout << "m_B = " << p.m_B << endl;
	return cout;
}
```

```cpp
void test01() {
	Person p(10,10);
	cout << p << endl;
}

int main() {
	test01();
	return 0;
}
```

> 总结：重载左移运算符配合友元可以实现输出自定义数据类型



#### 4.5.3 递增运算符重载

作用： 通过重载递增运算符，实现自己的整型数据

代码任务：实现前置递增和后置递增，然后实现 << 运算符重载实现 `cout` 直接打印对象。

```cpp
#include <iostream>
using namespace std;

//重载递增运算符

//自定义整型
```

```cpp
class MyInteger {
	friend ostream& operator<<(ostream& out, MyInteger myInt);
public:
	MyInteger():m_Num(0) {}
	//重载 ++ 运算符(前置)
	//注意返回引用
	MyInteger& operator++() {
		m_Num++;
		return *this;
	}
	//重载 ++ 运算符(后置)
	//int 代表一个占位参数，用于区分前置和后置递增
	//注意返回 值
	MyInteger operator++(int) {
		MyInteger temp = *this;
		m_Num++;
		return temp;
	}
private:
	int m_Num;
};
ostream& operator<<(ostream& out, MyInteger myInt) {
	out << myInt.m_Num;
	return out;
}
```

```cpp
void test01() {
	MyInteger myInt;//0
	cout << ++myInt << endl;//1
}

void test02() {
	MyInteger myInt;//0
	cout << myInt++ << endl;//0
	cout << myInt << endl;//1
}
int main() {
	test01();
	cout << endl;
	test02();
	return 0;
}
```

> 总结： 前置递增返回引用，后置递增返回值

**练习：重新实现 -- 运算符重载，要求前置后置都实现**

```cpp
#include <iostream>
using namespace std;

class MyInteger {
	friend ostream& operator<<(ostream& out, MyInteger myInt);
	int m_Num;
public:
	MyInteger() :m_Num(5) {}
	MyInteger(int num) :m_Num(num) {}
	MyInteger& operator--();//前置运算符
	MyInteger operator--(int);//后置运算符
};
ostream& operator<<(ostream& out, MyInteger myInt) {
	out << myInt.m_Num;
	return out;
}
MyInteger& MyInteger::operator--() {
	m_Num--;
	return *this;
}
MyInteger MyInteger::operator--(int) {
	MyInteger temp = *this;
	m_Num--;
	return temp;
}
```

```cpp
void test01() {
	//测试前置
	MyInteger a(10);
	cout << --a << endl;//9
	cout << --a << endl;//8
	cout << a << endl;//8
}
void test02() {
	//测试后置
	MyInteger a(10);
	cout << a-- << endl;//10
	cout << a-- << endl;//9
	cout << a << endl;//8
}
int main() {
	test01();
	cout << "-------\n";
	test02();
	return 0;
}
```



#### 4.5.4 赋值运算符重载

c++编译器至少给一个类添加4个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符 operator=，对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现 **深浅拷贝** 问题

**示例：**

```C++
#include <iostream>
using namespace std;
```

```cpp
class Person {
	int *m_Age;
public:
	Person(int age);
	~Person();
	Person& operator=(Person& p);
	int getAge();
};
Person::Person(int age) {
	m_Age = new int(age);
}
Person::~Person() {
	if (m_Age != nullptr) {
		delete m_Age;
		m_Age = nullptr;
	}
}
Person& Person::operator=(Person& p) {
	//自定义实现深拷贝
	//先判断本对象是否有属性在堆区，如有先释放
	if (m_Age != nullptr) {
		delete m_Age;
		m_Age = nullptr;
	}
	//然后再进行深拷贝
	m_Age = new int(p.getAge());
	return *this;
}
int Person::getAge() {
	return *m_Age;
}
```

```cpp
void test01() {
	//如果是浅拷贝，这里会重复释放两次空间导致出错
	//因此需要自定义 operator=
	//其实还要自定义 拷贝构造函数，这样就可以 Person p2 = p1; 不报错了
	Person p1(10);
	Person p2(15);
	p2 = p1;
	cout << "p1 的年龄为：" << p1.getAge() << endl;
	cout << "p2 的年龄为：" << p2.getAge() << endl;
}

int main() {
	test01();
	system("pause");
	return 0;
}
```



#### 4.5.5 关系运算符重载

**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作

**示例：**

```cpp
#include <iostream>
using namespace std;

//重载关系运算符 == !=
```

```cpp
class Person {
public:
	Person(string name, int age);
	bool operator==(Person& p);
	bool operator!=(Person& p);
	string m_Name;
	int m_Age;
};
Person::Person(string name, int age) {
	m_Name = name;
	m_Age = age;
}
bool Person::operator==(Person& p) {
	if (this->m_Name == p.m_Name && this->m_Age == p.m_Age) {
		return true;
	}
	return false;
}
bool Person::operator!=(Person& p) {
	return !(*this == p);
}
```

```cpp
void test01() {
	Person p1("Tom", 18);
	Person p2("Tom", 18);
	Person p3("Jerry", 19);
	if (p1 == p2) cout << "p1 和 p2 是相等的" << endl;
	if (p1 != p3) cout << "p1 和 p3 是不相等的" << endl;
}
int main() {
	test01();
	return 0;
}
```



#### 4.5.6 函数调用运算符重载（仿函数）

* 函数调用运算符 ()  也可以重载
* 由于重载后使用的方式非常像函数的调用，因此称为仿函数
* 仿函数没有固定写法，非常灵活

这里只是对仿函数进行一个初步了解，后续会详细学习。

**示例：**

```cpp
#include <iostream>
#include <string>
using namespace std;

//函数调用运算符重载
```

```cpp
//打印输出类
class MyPrint {
public:
	//重载函数调用运算符
	void operator()(string test) {
		cout << test << endl;
	}
};

void test01() {
	cout << "---test01---" << endl;
	MyPrint myPrint;
	myPrint("HelloWorld!");//对象直接当函数用
	cout << "---test01END---" << endl;
}
```

```cpp
//仿函数非常灵活，没有固定写法
class MyAdd {
public:
	int operator()(int num1, int num2) {
		return num1 + num2;
	}
};

void test02() {
	cout << "---test02---" << endl;
	MyAdd myadd;
	cout << myadd(1, 2) << endl;//3
	//甚至可以匿名函数对象
	cout << MyAdd()(1, 2) << endl;//3
	cout << "---test02END---" << endl;
}

```

```cpp
int main() {
	test01();
	test02();
	return 0;
}
```

