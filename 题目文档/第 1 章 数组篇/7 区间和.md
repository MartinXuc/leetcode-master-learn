[toc]

- [卡码网题目链接](https://kamacoder.com/problempage.php?pid=1070)
- [代码随想录链接](https://www.programmercarl.com/kamacoder/0058.%E5%8C%BA%E9%97%B4%E5%92%8C.html#%E6%80%9D%E8%B7%AF)

## 题目思路

本题需要对同一个数组上多个不同的区间计算区间和，如果每次都进行累加那么复杂度就会非常大，这种题目一个常见的思路就是计算前缀和，我猜测代码随想录也是用的这个方法。先写一版看看吧。

然后本题貌似是 ACM 模式的输入，需要自己实现输入输出的代码，问题看起来不大。

## 代码实现

python

```python
n = int(input())
array = []

# 输入数组
for _ in range(n):
    array.append(int(input()))

# 计算前缀和
prifix_sum_array = [array[0]]
for i in range(1, n):
    temp = prifix_sum_array[i - 1] + array[i]
    prifix_sum_array.append(temp)
prifix_sum_array.append(0) # 让下方求区间和时，a = 0 的情况计算正确

# 快速求区间和
while(True):
    try:
        a, b = map(int, input().split())
        a = int(a)
        b = int(b)
        range_sum = prifix_sum_array[b] - prifix_sum_array[a - 1]
        print(range_sum)
    except:
        break
```

C++

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> nums(n, 0);
    for (int& i : nums) {
        cin >> i;
    }
    // 计算前缀和：定义为 sum[nums[0], nums[n - 1]]
    vector<int> prefix_sum(n + 1, 0);
    for (int i = 1; i < prefix_sum.size(); ++i) {
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1];
    }
    // 计算区间和
    int left, right;
    while(cin >> left >> right) {
        cout << prefix_sum[right + 1] - prefix_sum[left] << endl;
    }
    return 0;
}
```

## 看录后想法

学到了 C++ 中如果大量输入数据使用 scanf 速度更快，而 scanf 的返回值是成功读取到的元素个数，读到 EOF 的时候返回 -1，因此可以 `while(~scanf(xx))` 来方便地读取数据，`~` 表示按位取反，如果正确读入则取反后应当是一个负数，会被转换成 true，读到 EOF 的话 -1 按位取反会变成 0（涉及补码 与 反码 的知识）。