[toc]

- [题目链接](https://kamacoder.com/problempage.php?pid=1044)
- [代码随想录链接](https://www.programmercarl.com/kamacoder/0044.%E5%BC%80%E5%8F%91%E5%95%86%E8%B4%AD%E4%B9%B0%E5%9C%9F%E5%9C%B0.html)

## 题目思路

感觉本题直接去遍历求得最小值也不会很麻烦，但是有没有更优的算法呢？可以考虑上一题的前缀和的思路，创建一个行前缀和矩阵和列前缀和矩阵。嗯，因为分配方式的单一，或许前缀和不需要用矩阵来存，直接用一维数组存即可。

## 代码实现

```python
n, m = map(int, input().split())
land = [list(map(int, input().split())) for _ in range(n)]
# 按行切分的前缀和
prefix_row = [0] * n
prefix_row[0] = sum(land[0])
for i in range(1, n):
    prefix_row[i] = prefix_row[i - 1] + sum(land[i])
# 按列切分的前缀和
land_t = list(zip(*land)) # 转置
prefix_col = [0] * m
prefix_col[0] = sum(land_t[0])
for i in range(1, m):
    prefix_col[i] = prefix_col[i - 1] + sum(land_t[i])
# 按行切分计算价值差异
min_diff = prefix_row[n - 1]
for i in range(0, n - 1):
    diff = abs(prefix_row[n - 1] - prefix_row[i] * 2)
    min_diff = min(min_diff, diff)
# 按列切分计算价值差异
for i in range(0, m - 1):
    diff = abs(prefix_col[m - 1] - prefix_col[i] * 2)
    min_diff = min(min_diff, diff)
print(min_diff)
```

## 看录后想法



## 小结