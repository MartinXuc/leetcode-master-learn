- [题目链接](https://leetcode.cn/problems/4sum/)
- [代码随想录链接](https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

## 题目思路

四数之和能否借鉴前面三数之和的思路呢，这是做这道题之前首先想到的问题。如果借鉴前面的思路，就是两个指针正常遍历，然后再来两个指针搞类似于三数之和的双指针。

## 代码实现

```python
class Solution:
    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:
        i, j, l, r, sum_ = 0, 0, 0, 0, 0
        nums.sort()
        print(nums)
        ans = []
        i = 0
        while i < len(nums) - 3:
            j = i + 1
            while j < len(nums) - 2:
                l = j + 1
                r = len(nums) - 1

                while l < r:
                    sum_ = nums[i] + nums[j] + nums[l] + nums[r]
                    if sum_ < target:
                        l += 1
                    elif sum_ > target:
                        r -= 1
                    else:
                        ans.append([nums[i], nums[j], nums[l], nums[r]])
                        l += 1
                        r -= 1
                        # l, r 去重
                        while l < len(nums) and nums[l - 1] ==nums[l]:
                            l += 1
                        while r > 0 and nums[r + 1] == nums[r]:
                            r -= 1
                # lr 遍历完毕后，j 再去重
                j += 1
                while j < len(nums) - 2 and nums[j - 1] == nums[j]:
                    j += 1
            # j 遍历完毕后 i 再去重
            i += 1
            while i < len(nums) - 3 and nums[i - 1] == nums[i]:
                i += 1
        return ans
    
if __name__ == "__main__":
    nums = [2,2,2,2,2]
    target = 8
    print(Solution().fourSum(nums, target))
```

## 看录后想法

思路是一致的，而且对于更高的维度 n 数之和，也是一样的解法，通过最后的双指针复杂度可以降一级。然后录里还讲了一些剪枝的操作，我其实写得时候也考虑了，但是觉得复杂到一定程度的话，收益可能就不大了，因此没有写上。

## 小结

还是比较困难的题目的，花了不少时间在边界处理上。