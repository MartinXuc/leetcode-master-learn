- [题目链接](https://leetcode.cn/problems/3sum/)
- [代码随想录链接](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

## 题目思路

1. 由于需要去重，所以过程中必然是用下标操作数组是更加合适的。
2. 假设三个下标 i j k，可以保证在 i < j < k 的情况下可以遍历完所有的情况
3. k 从 0 开始，累加到结尾
4. 每次查询 `nums[k]` 是否在哈希表中，在的话就可以往 ans 里塞了
5. 每一次更新 k 之后，都可以更新一次哈希字典，哈希字典存放的是 `-sum : [(i, j), ...]`，让 j = k 即可实现，不漏地遍历完，所以就不用创建一个变量 j 了。
基本就是这样的一个思路了。

## 代码实现

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        hash_dict = dict()
        ans_set = set()
        for k in range(1, len(nums)):
            # 查询 nums[k] 是否能找到要求的配对组成三元组
            if nums[k] in hash_dict:
                for i, j in hash_dict[nums[k]]:
                    ans_set.add(tuple(sorted([nums[i], nums[j], nums[k]])))
            # 更新 hash_dict
            for i in range(k):
                sum_ = -(nums[i] + nums[k])
                if hash_dict.get(sum_) is None:
                    hash_dict[sum_] = list()
                hash_dict[sum_].append((i, k))
        return list(ans_set)
```

这个写法会导致超时！想想是否可能加上一个门限，当相同元素的个数超过 2 个的时候就没有统计进去的意义了，除了 （0,0,0）的情况。所以可以先统计元素个数，然后去除超过限度没有意义的个数，再按值排个序，后面做起来也方便。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 统计元素的个数
        num_dict = dict()
        for num in nums:
            if num_dict.get(num) is None:
                num_dict[num] = 0
            # 无意义的个数不统计
            if num == 0:
                num_dict[num] = min(num_dict[num] + 1, 3)
            else:
                num_dict[num] = min(num_dict[num] + 1, 2)
        # 按元素排序
        num_dict = dict(sorted(num_dict.items(), key = lambda item: item[0]))
        nums = [num for num, count in num_dict.items() for _ in range(count)]

        hash_dict = dict()
        ans_set = set()
        for k in range(1, len(nums)):
            # 查询 nums[k] 是否能找到要求的配对组成三元组
            if nums[k] in hash_dict:
                for i, j in hash_dict[nums[k]]:
                    ans_set.add(tuple(sorted([nums[i], nums[j], nums[k]])))
            # 更新 hash_dict
            for i in range(k):
                sum_ = -(nums[i] + nums[k])
                if hash_dict.get(sum_) is None:
                    hash_dict[sum_] = list()
                hash_dict[sum_].append((i, k))
        return list(ans_set)
```

发现还是超时，后面即便优化了第二个小的 sort 也依然超时，到这里就应该怀疑自己的思路出了问题。由于时间有限，暂时先看录吧。

## 看录后想法

录里给出了先排序后使用双指针的解法，复杂度也是 `n^2`，但是看样子计算量实际上会小不少，先把这个方法实现出来，然后再思考为什么吧。

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums.sort()
        for i in range(len(nums) - 2):
            # 若上一个元素和当前一样，没有必要继续做下去了
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left = i + 1
            right = len(nums) - 1
            while left < right:
                sum_ = nums[i] + nums[left] + nums[right]
                if sum_ < 0:
                    left += 1
                elif sum_ > 0:
                    right -= 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    # 找到之后需要进行去重的逻辑，也就是重复元素不继续计算
                    while right > 0 and nums[right - 1] == nums[right]:
                        right -= 1
                    right -= 1
                    while left < len(nums) - 1 and nums[left] == nums[left + 1]:
                        left += 1
                    left += 1
        return ans
```

## 小结

虽然两种方式复杂度都是 `O(n^2)`，但是实际上在这种数据量下常数级的操作是不可以忽略的，第一种思路的操作复杂程度至少是第二种的 3 倍！使用了大量的哈希运算，看似是 O(1) 但是实际上的运算量一点也不小。